<!DOCTYPE HTML>
<html lang="en-US" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>A User’s Guide to the Ferrilab Project</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="A more thorough exploration of Ferrilab’s crates.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="./guide/assets/mdbook-admonish.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">A User’s Guide to the Ferrilab Project</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/ferrilab/ferrilab" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="dedication"><a class="header" href="#dedication">Dedication</a></h1>
<p>I began working on <code>bitvec</code> shortly before I was told that my father had been
diagnosed with cancer for the third time. Developing the library gave me
something into which to sink my attention and keep my mind from dwelling on his
rapidly-progressing illness. I wrote the core pointer representation that
enables <code>bitvec</code>’s modern behavior at his side, in the last days that he
remained conscious.</p>
<p>I never had the chance to explain to my dad what I was building. By the time it
was developed enough to be worth explaining, he had lost too much of his brain
to understand me. More than anything I’ve done for my employers, <code>bitvec</code> is the
work of which I’m most proud, and which I most wish he could have seen.</p>
<p>The Ferrilab project, and in particular <code>bitvec</code>, is dedicated to the memory of
my father, George M. Payne, who inspired me to build quality work, supported my
search for my talents, and taught me to labor for the benefit of others beyond
myself.</p>
<p>—Alexander Payne (myrrlyn)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction-to-ferrilab"><a class="header" href="#introduction-to-ferrilab">Introduction to Ferrilab</a></h1>
<p>Ferrilab is an umbrella project for crates that experiment with reshaping the
Rust data model about primitive types. It began with the <code>bitvec</code> crate; as
<code>bitvec</code> expanded, it eventually spun off its integer-generalization into
<code>funty</code>, and <code>radium</code> was created independently but swiftly brought into the
fold.</p>
<p>Ferrilab is currently focused on just these three crates, but may expand in the
future as we discover new ideas to try out.</p>
<h2 id="behind-the-name"><a class="header" href="#behind-the-name">Behind the Name</a></h2>
<p>The primary maintainer, myrrlyn, is from the Great Lakes region of the Americas
and the crates here all reshape the fundamental types in the Rust language. We
looked for names that had to do with early modern physics, and settled on Enrico
Fermi, as he worked in atomic physics, has an eponymous laboratory near Chicago,
and Fermilab was a single edit step away from Rust’s mascot.</p>
<p><small>Plus, <code>bitvec</code> began while myrrlyn was working for the US Government in
New Mexico…</small></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="radium"><a class="header" href="#radium">Radium</a></h1>
<p>The <a href="https://crates.io/crates/radium"><code>radium</code></a> crate provides a unifying model for shared-mutability over the
primitives. It does <em>not</em> handle more complex shared-mutability topics such as
mutices or locks: if you need to manage large structured data, you will need to
look elsewhere.</p>
<h2 id="radium-trait"><a class="header" href="#radium-trait"><code>Radium</code> Trait</a></h2>
<p>This trait allows your code to generically accept either an atomic type or a
<code>Cell</code> and interact with it through a unified API. It is implemented by all of
the standard library atomics, <code>Cell&lt;{bool,{i,u}{8,16,32,64,128,size},*mut T}&gt;</code>,
and the type families that Radium provides (described below).</p>
<p>The primitive type that a <code>Radium</code> implementor encloses is indicated by the
<code>Radium::Item</code> associated type. You can use this as a constraint in your trait
bounds (i.e. <code>&lt;R: Radium&lt;Item = i32&gt;&gt;</code>) in order to gain direct access to the
primitive, or you can require that <code>R::Item</code> implement other traits and interact
with it through them.</p>
<h2 id="type-aliases"><a class="header" href="#type-aliases">Type Aliases</a></h2>
<p>Radium provides type aliases for each primitive which <em>could</em> be atomic in the
standard library. The <code>Radium{Bool,{I,U}{8,16,32,64,128,size},Ptr}</code> symbols all
forward to their corresponding <code>AtomicType</code> when that symbol exists, or to
<code>Cell&lt;Type&gt;</code> when it does not.</p>
<p>Since these are type aliases rather than newtypes, you can globally replace the
<code>AtomicT</code> symbols with their <code>RadiumT</code> equivalent without any other changes to
your codebase.</p>
<h2 id="type-families"><a class="header" href="#type-families">Type Families</a></h2>
<p>Radium provides three type families which accept fundamentals as type
parameters. These families have no inherent API, and only implement <code>Radium</code>,
<code>Debug</code>, <code>Default</code>, and <code>From&lt;T&gt;</code>. They may or may not have a <code>Sync</code>
implementation, depending on whether they have atomic behavior.</p>
<ol>
<li>
<p>The <code>Atom&lt;T&gt;</code> family corresponds to (and wraps) the standard library’s
<code>core::sync::atomic::*</code> types. This family only accepts <code>T</code> parameters where
an equivalent <code>AtomicT</code> symbol exists for the target; this means that on
targets which do not have, for instance, <code>AtomicU64</code>, <code>Atom&lt;u64&gt;</code> will fail
to compile. These are always <code>Sync</code>.</p>
<p><code>Atom</code> requires that type arguments implement <code>radium::marker::Atomic</code>.</p>
</li>
<li>
<p>The <code>Isotope&lt;T&gt;</code> family functions similarly to <code>Atom&lt;T&gt;</code>, except that it
wraps Radium’s <code>RadiumT</code> type aliases. As such, <code>Isotope</code> is portable across
targets with different atomic supports, and will never fail to compile;
however, it will silently degrade from atomic to <code>Cell</code> behavior (including
loss of <code>Sync</code>) when the requisite atomic types are missing.</p>
<p><code>Isotope</code> requires that type arguments implement <code>radium::marker::Nuclear</code>.</p>
</li>
<li>
<p>The <code>Radon&lt;T&gt;</code> family is a wrapper over <code>Cell&lt;T&gt;</code>. Like <code>Isotope</code>, it
requires that type arguments implement <code>radium::marker::Nuclear</code>. It is never
<code>Sync</code>.</p>
</li>
</ol>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<p>This contrived example is taken from <code>radium/examples/schroedinger.rs</code>. It
shows how the <code>Radium</code> trait can be used by a worker function to manipulate
data, and how the different types can be used to work in sequence or in
parallel.</p>
<blockquote>
<p>Note: Radium’s MSRV is 1.60, while the scoped-threads API used here stabilized
in 1.63.</p>
</blockquote>
<pre><code class="language-rust">use radium::{Radium, types::{RadiumU64, Atom, Isotope, Radon}};
use std::{
  cell::Cell,
  sync::atomic::{AtomicU64, Ordering},
  thread,
  time::Duration,
};

fn do_work&lt;R: Radium&lt;Item = u64&gt;&gt;(this: &amp;R, ident: u8) {
  let on_entry = this.load(Ordering::SeqCst);
  println!("{: &gt;2} step 0 sees: {: &gt;2}", ident, on_entry);

  let before_add = this.fetch_add(10, Ordering::SeqCst);
  println!("{: &gt;2} step 1 sees: {: &gt;2}", ident, before_add);

  let after_add = this.load(Ordering::SeqCst);
  println!("{: &gt;2} step 2 sees: {: &gt;2}", ident, after_add);

  thread::sleep(Duration::from_millis(after_add));

  let before_sub = this.fetch_sub(3, Ordering::SeqCst);
  println!("{: &gt;2} step 3 sees: {: &gt;2}", ident, before_sub);

  let on_exit = this.load(Ordering::SeqCst);
  println!("{: &gt;2} step 4 sees: {: &gt;2}", ident, on_exit);
}

static ATOM: AtomicU64 = AtomicU64::new(0);
static RADIUM: RadiumU64 = RadiumU64::new(0);

fn main() {
  let cell = Cell::new(0u64);

  let atom = Atom::new(0u64);
  let isotope = Isotope::new(0u64);
  let radon = Radon::new(0u64);

  println!("atoms");
  thread::scope(|s| for ident in 0 .. 3 {
    s.spawn(move || do_work(&amp;ATOM, ident));
  });
  println!();
  thread::scope(|s| for ident in 3 .. 6 {
    let atom = &amp;atom;
    s.spawn(move || do_work(atom, ident));
  });
  println!();

  println!("isotopes");
  thread::scope(|s| for ident in 6 .. 9 {
    s.spawn(move || do_work(&amp;RADIUM, ident));
  });
  println!();
  for ident in 9 .. 12 {
    do_work(&amp;isotope, ident);
  }
  println!();

  println!("cells");
  for ident in 12 .. 15 {
    do_work(&amp;cell, ident);
  }
  println!();
  for ident in 15 .. 18 {
    do_work(&amp;radon, ident);
  }
  println!();
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="funty"><a class="header" href="#funty"><code>funty</code></a></h1>
<p>The <code>funty</code> crate (<em><strong>fun</strong></em>damental <em><strong>ty</strong></em>pes) provides traits that unify
the Rust non-pointer primitives. It also unifies pointers and references by
lifting access permissions into the trait system.</p>
<h2 id="fundamental-unification"><a class="header" href="#fundamental-unification">Fundamental Unification</a></h2>
<p>The Rust primitives implement the following trait hierarchy and replicate their
standard-library inherent API and trait implementations.</p>
<ul>
<li><strong><code>Fundamental</code></strong>: this is implemented by all primitives: <code>bool</code>, <code>char</code>, all
integers, and both floats. It requires all traits that <em>all</em> primitives
implement, and provides <code>.as_other()</code> methods that can replace <code>as</code>-casts.
<ul>
<li><strong><code>Numeric</code></strong>: this is implemented by all integers and both floats. It adds
the arithmetic operator traits, and methods for converting between the
integer and its raw byte representation.
<ul>
<li><strong><code>Integral</code></strong>: this is implemented by all integers. It adds bit-wise
operator traits, attempted conversions between the other integers, and
bit-shifts. It also provides most of the integer inherent API, as most of
these methods are sign-agnostic.
<ul>
<li><strong><code>Signed</code></strong>: this is implemented only by signed integers. It adds the
absolute-value and sign-testing functions that unsigned integers don’t
support.</li>
<li><strong><code>Unsigned</code></strong>: this is implemented only by unsigned integers. It
provides the <code>{is,next}_power_of_two</code> one-hot methods that only make
sense on unsigned integers.</li>
</ul>
</li>
<li><strong><code>Floating</code></strong>: this is implemented by the floating-point numbers. Unlike
the integral traits, it has a great deal of methods that only exist when
<code>cfg(feature = "std")</code> is active, as they require the platform <code>libm</code>
mathematics library and are not provided by Rust’s <code>core</code> crate. It also
provides both all of the associated constants, as well as all of the
constants stored in eponymous modules but <em>not</em> associated with the actual
floating-point primitive types.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Additionally, <code>funty</code> provides marker traits for selecting bit-width: for <code>N</code>
in <code>8</code>, <code>16</code>, <code>32</code>, <code>64</code>, and <code>128</code>, the <code>IsN</code> trait is implemented by types
that are exactly that wide, <code>AtLeastN</code> is implemented by types that are that
width or more, and <code>AtMostN</code> is implemented by types that are that width or
less.</p>
<p>You can use these traits as generic constraints in code that needs to accept a
range of different primitives. The integral traits provide Peano constants (zero
and one), and can be constructed from literals for non-<code>const</code> work.</p>
<h2 id="pointer-unification"><a class="header" href="#pointer-unification">Pointer Unification</a></h2>
<p>The <code>funty::ptr</code> module provides <code>Pointer</code> and <code>NonNullPtr</code> types which are
replacements for raw pointers and <code>core::ptr::NonNull</code>, respectively. They work
by lifting the <code>*const T</code>/<code>*mut T</code> distinction into the trait system, through
the <code>Permission</code> trait and the <code>Shared</code>, <code>Unique</code>, and <code>(Shared, Unique)</code> types.</p>
<p>The <code>Permission</code> trait and its implementors implement a less-capable version of
the stacked-borrows experimental model found in Miri. <code>Pointer&lt;T, P&gt;</code> implements
the read-only APIs found on both <code>*const</code> and <code>*mut</code> pointers, while
<code>Pointer&lt;T, Unique&gt;</code> alone implements the write APIs only present on <code>*mut</code>
pointers. Additionally, type-level transitions allow <em>safely</em> casting <code>Unique</code>
pointers down to read-only and back up to <code>Unique</code>, and <em>unsafely</em> casting
directly to a permission that you specify.</p>
<p>The <code>NonNullPtr</code> behaves similarly to <code>Pointer</code>, except that it encloses a
<code>core::ptr::NonNull</code> in order to regain the null-pointer niche optimization. Its
API strives to match both the <code>NonNull</code> and <code>Pointer</code> APIs. As both raw pointers
and <code>NonNull</code> still have large amounts of unstable API surface in the standard
library, these types will continue to grow in response to both Ferrilab’s needs
and the standard library’s evolution.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="permission-changes"><a class="header" href="#permission-changes">Permission Changes</a></h1>
<p><code>funty</code> uses the <code>Permission</code> trait to create a graph of safe transitions
between raw pointers and <code>Pointer</code>, and between different type parameters
attached to <code>Pointer</code> values.</p>
<p><code>Pointer</code>s can be constructed from both raw pointers: <code>*const T</code> produces
<code>Pointer&lt;T, Shared&gt;</code>, and <code>*mut T</code> produces <code>Pointer&lt;T, Unique&gt;</code>. Once
constructed, all <code>Pointer&lt;T, P: Permission&gt;</code> values have access to the
introspective and read-only memory accesses defined on the raw pointers. The
memory-write APIs are only available on <code>Pointer&lt;T, Unique&gt;</code>.</p>
<p>Additionally, the method <code>.cast_shared()</code> moves <code>Pointer</code>s from <code>P</code> to
<code>(Shared, P)</code>. The <code>(Shared, P: Permission)</code> tuple is itself an implementor of
<code>Permission</code>, and can continue to be used as a read-only pointer.
<code>Pointer&lt;T, (Shared, P)&gt;</code> also provides <code>.cast_unshared()</code>, which undoes
<code>.cast_shared()</code> and transitions from <code>(Shared, P)</code> back to <code>P</code>.</p>
<p>All <code>Pointer</code>s can produce <code>*const</code> raw pointers, but only the <code>Unique</code>
permission can produce <code>*mut</code> raw pointers. If you need access to <code>*mut</code>
raw pointers but are in generic code where you cannot satisfactorily prove to
the compiler that you have a <code>Unique</code>, you have two options. The
<code>.unwind_to_unique()</code> method recursively unwinds a <code>(Shared, P)</code> history stack
until it reaches the base, then produces <code>Some</code> pointer if the original
permission was <code>Unique</code> or <code>None</code> if it was <code>Shared</code>. The <code>unsafe</code> method
<code>.cast_mut()</code> unconditionally produces a pointer with <code>Unique</code> permissions, but
may violate Rust’s provenance rules and invoke undefined behavior.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bitvec"><a class="header" href="#bitvec"><code>bitvec</code></a></h1>
<p>This is Ferrilab’s largest, most complex, project and likely the reason you’re
reading this guide. It provides a system that allows Rust code to treat memory
as if it were bit-addressed, rather than byte-addressed, and strives to be the
most <em>correct</em> and <em>capable</em> such bit-addressing system available. This results
in some unavoidable complexity and performance loss, and we are always working
to improve the quality of generated code.</p>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p><code>bitvec</code> was built out of myrrlyn’s experience and frustration with performing
I/O buffer manipulation using C, C++, and Ruby. His work required programs
capable of dynamically selecting an arbitrary region of a bit-stream (a task to
which C’s structural bitfield declarations are unsuited), and it required those
programs to be fast and portable to flight embedded systems (adjectives not
commonly associated with Ruby engines).</p>
<p>Furthermore, his work involved message schemas that were permitted to select a
bit ordering at the packet and field level. This is <em>not</em> a behavior that any
existing bit-stream library or language feature provides. These experiences
informed his goals and design choices from the very beginning.</p>
<p><code>bitvec</code> matches, and exceeds, the functionality of every other bit-stream
implementation we have found. It is also the only Rust crate that is a drop-in
replacement for standard library types, and is able to do so while remaining
well-formed and conformant to Rust’s rules about memory access. Thanks to
excellent compiler engineering by the Rust and LLVM teams, it is able to do this
while still producing reasonably good output code.</p>
<h2 id="goals-for-this-guide"><a class="header" href="#goals-for-this-guide">Goals for This Guide</a></h2>
<p>We hope that this guide will explain <code>bitvec</code>’s design choices, philosophy,
backing theory, and overall goals. It is not a detailed exploration of the crate
API – this is <a href="https://docs.rs/bitvec/latest/bitvec">hosted on docs.rs</a> – but instead seeks to communicate how
to think about <code>bitvec</code> so that you will know how to best use the APIs it
offers.</p>
<p>The best way I (myrrlyn) know how to communicate this information is as a
dialogue between me, the author, and you, the user. Since this is a book, not a
live conversation, I actively encourage you to get in contact with me with any
questions or feedback through the channels listed in Ferrilab’s <a href="https://github.com/ferrilab/ferrilab/blob/main/CONTRIBUTING.md">CONTRIBUTING</a>
document, and throughout the guide I will periodically remind you that if a
section is unclear, it is an error on my part, and I would appreciate an issue
or other contact so that I can improve it.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data-structures"><a class="header" href="#data-structures">Data Structures</a></h1>
<p><code>bitvec</code>’s primary exports are four data structures: <a href="https://docs.rs/bitvec/latest/bitvec/slice/struct.BitSlice.html"><code>BitSlice</code></a>, <a href="https://docs.rs/bitvec/latest/bitvec/array/struct.BitArray.html"><code>BitArray</code></a>,
<a href="https://docs.rs/bitvec/latest/bitvec/boxed/struct.BitBox.html"><code>BitBox</code></a>, and <a href="https://docs.rs/bitvec/latest/bitvec/vec/struct.BitVec.html"><code>BitVec</code></a>. These correspond to the <a href="https://doc.rust-lang.org/stable/std/primitive.slice.html"><code>[bool]</code></a>,
<a href="https://doc.rust-lang.org/stable/std/primitive.array.html"><code>[bool; N]</code></a>, <a href="https://doc.rust-lang.org/stable/alloc/boxed/struct.Box.html"><code>Box&lt;[bool]&gt;</code></a>, and <a href="https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html"><code>Vec&lt;bool&gt;</code></a> types in the
Rust standard libraries. Unlike the Rust types, the <code>bitvec</code> types are not
composable, and cannot be mixed with any other types, including pointers in the
standard library.</p>
<pre><code class="language-admonish danger">You **cannot** produce `Box&lt;BitSlice&gt;`, `Rc&lt;BitSlice&gt;`, or `Arc&lt;BitSlice&gt;`;
attempts to do produce or use these may induce undefined behavior.
</code></pre>
<p>The <code>bitvec</code> types implement the APIs of their standard-library counterparts to
the fullest extent possible. The only missing feature is currently
<code>IndexMut&lt;usize&gt;</code>, preventing <code>collection[index] = bit;</code> assignment. This means
that, for users looking for compact <code>usize =&gt; bool</code> collections, substituting
types in your project codebase ought to be enough to make your project Just
Work™️.</p>
<p>It is the fact that <code>BitSlice</code> acts exactly like <code>[bool]</code>, and can only be used
through <code>&amp;BitSlice</code> and <code>&amp;mut BitSlice</code> references, that makes <code>bitvec</code> unique.
No other Rust library has this capability.</p>
<p>Before we explore the data structures in more detail, there are three caveats I
must provide:</p>
<ol>
<li>
<p><code>bitvec</code> uses an opaque, custom, pointer representation for everything except
<code>BitArray</code>. You may not inspect or modify this pointer. You may not use it as
a type or value parameter in any other types or functions. You will break
your program if you try.</p>
<p><code>bitvec</code> ensures that this pointer encoding does not fail the compiler and
language requirements for reference correctness. The rules used to do so are
internal to the crate, and will not be present outside it. <code>bitvec</code> pointers
are perfectly safe to use, as long as you treat them as completely opaque and
use <em>only</em> the interfaces provided.</p>
<p>Standard-library smart pointers do not understand this encoding and would
attempt to dereference the encoded pointer; this is why trying to use
<code>BitSlice</code> with them is undefined.</p>
</li>
<li>
<p>These structures all have two type parameters, <code>&lt;T: BitStore, O: BitOrder&gt;</code>.
These parameters are described in the next chapter. They govern the in-memory
representation of data storage, but are not relevant to the general use of the
handle types.</p>
</li>
<li>
<p><code>bitvec</code> trades an increased memory space efficiency for decreased
instruction size and speed efficiency. The compiler <em>may</em> optimize some of
the costs away, but <code>bitvec</code> structures are not free to use. The “zero-cost”
of the <code>bitvec</code> abstraction is that you cannot write a better bitset, and
<em>not</em> that it is equal in runtime performance to an ordinary <code>bool</code> sequence.</p>
</li>
</ol>
<p>Now that the disclaimers are over, we can talk about how the types actually
work.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="slices"><a class="header" href="#slices">Slices <!-- omit in toc --></a></h1>
<ol>
<li><a href="bitvec/data-structures/bitslice.html#getting-a-bitslice">Getting a <code>BitSlice</code></a>
<ol>
<li><a href="bitvec/data-structures/bitslice.html#borrowing-constructors">Borrowing Constructors</a></li>
<li><a href="bitvec/data-structures/bitslice.html#macro-constructor">Macro Constructor</a></li>
</ol>
</li>
<li><a href="bitvec/data-structures/bitslice.html#what-bitslice-can-do">What <code>BitSlice</code> Can Do</a>
<ol>
<li><a href="bitvec/data-structures/bitslice.html#-that-bool-can">… That <code>[bool]</code> Can</a></li>
<li><a href="bitvec/data-structures/bitslice.html#-that-bool-cannot">… That <code>[bool]</code> Cannot</a></li>
<li><a href="bitvec/data-structures/bitslice.html#set-queries">Set Queries</a></li>
<li><a href="bitvec/data-structures/bitslice.html#boolean-arithmetic">Boolean Arithmetic</a></li>
<li><a href="bitvec/data-structures/bitslice.html#writing-to-memory">Writing To Memory</a></li>
<li><a href="bitvec/data-structures/bitslice.html#viewing-the-underlying-memory">Viewing the Underlying Memory</a></li>
</ol>
</li>
<li><a href="bitvec/data-structures/bitslice.html#footnotes">Footnotes</a></li>
</ol>
<p>The base type of the project is <code>BitSlice</code>. This is a region type, like
<code>[bool]</code>, and cannot be held directly. Instead, it is accessed by borrowed
references (<code>&amp;BitSlice</code>, <code>&amp;mut BitSlice</code>) or owning handles (<code>BitArray</code>,
<code>BitBox</code>, <code>BitVec</code>). The distinction between the handles and the region is the
same as it is in ordinary Rust types.</p>
<p>The <code>BitSlice</code> region is able to begin and end at any bit in memory, and is not
restricted to having one edge aligned to the edge of its initial element. This
restriction, present in all of its competitors, is removed through the use of a
special encoding in all pointers to the region, which stores the starting bit of
the base element in part of the slice pointer that describes the real memory.</p>
<p>There are eight bits to a byte on all systems Rust targets, and therefore the
index of a bit within a byte is itself three bits wide. These bits are taken
from the length counter of a slice pointer, which means that <code>BitSlice</code> is able
to address only ⅛<sup>th</sup> of the indices that <code>[bool]</code> can.</p>
<pre><code class="language-admonish info">This is 64 [Mebibytes] on a 32-bit system, and 256 [Pebibytes] on a 64-bit
system. If you can even allocate that much real memory in one handle, then you
have very different operating conditions than I can help you with.

[Mebibytes]: https://en.wikipedia.org/wiki/Mebibyte
[Pebibytes]: https://en.wikipedia.org/wiki/Pebibyte
</code></pre>
<h2 id="getting-a-bitslice"><a class="header" href="#getting-a-bitslice">Getting a <code>BitSlice</code></a></h2>
<p><code>BitSlice</code> is strictly a borrowed region. It can neither be created nor
destroyed; rather, views to it are acquired from a memory buffer that some other
binding owns.</p>
<p>The <a href="bitvec/data-structures/../type-parameters/bitstore.html"><code>BitStore</code> chapter</a> covers this in more detail, but only slices of the
unsigned integers <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>usize</code>, and (on 64-bit targets) <code>u64</code> can
be used as the source memory for a <code>BitSlice</code>. (You can also use their <code>Cell&lt;&gt;</code>
wrappers or atomic variants; this will be discussed later).</p>
<h3 id="borrowing-constructors"><a class="header" href="#borrowing-constructors">Borrowing Constructors</a></h3>
<p>The simplest way to create a <code>BitSlice</code> reference is to borrow it from ordinary
Rust data. The <a href="https://docs.rs/bitvec/latest/bitvec/view/trait.BitView.html"><code>BitView</code></a> trait, available in the <a href="https://docs.rs/bitvec/latest/bitvec/prelude">prelude</a>, implements methods
on the supported unsigned integers, all arrays of them, and their slices.</p>
<pre><code class="language-rust">use bitvec::prelude::*;

let byte = 0u8;
let bits = byte.view_bits::&lt;LocalBits&gt;();

let array = [0u16; 2];
let bits = array.view_bits::&lt;Lsb0&gt;();

let mut array = [0u32; 3];
let slice = &amp;mut array[..];
let bits = slice.view_bits_mut::&lt;Msb0&gt;();</code></pre>
<p>The <code>.view_bits()</code> and <code>.view_bits_mut()</code> methods take the other type parameter
<code>bitvec</code> requires. This is described in the <a href="bitvec/data-structures/../type-parameters/bitorder.html"><code>BitOrder</code> chapter</a>. Use <code>Lsb0</code>
until you have a specific need for a more precise parameter.</p>
<p>In addition, <code>BitSlice</code> offers constructor functions <code>::from_element()</code>,
<code>::from_slice()</code>, and their <code>_mut</code> variants, which borrow elements and slices,
respectively, and construct <code>&amp;/mut BitSlice</code> references from them. The trait
methods are generally easier, and certainly shorter to write, but they all do
the same work.</p>
<p>Lastly, empty slices can be produced with the <code>::empty()</code> or <code>::empty_mut()</code>
functions, since there is no <code>&amp;[]</code> or <code>&amp;mut []</code> literal available.</p>
<h3 id="macro-constructor"><a class="header" href="#macro-constructor">Macro Constructor</a></h3>
<p>In addition to these method constructors, you may also use the <a href="https://docs.rs/bitvec/latest/bitvec/macro.bits.html"><code>bits!</code></a>
constructor macro. This macro runs at compile-time to produce a buffer
containing the correct data values, then borrows it as a <code>BitSlice</code> reference.
It is a <code>macro_rules!</code> macro, not a procedural macro, and should not have a
significant impact on your compilation times.</p>
<p>By default, the produced buffer is a temporary that the compiler will then
extend to have the minimum lifetime of the produced reference handle. However,
you can use the <code>static</code> keyword to cause the macro to produce a hidden and
unnameable <code>static BitArray</code> backing buffer, which then provides the
<code>&amp;'static BitSlice</code> lifetime. Since this <code>static</code> buffer cannot be named, it is
safe to use even when <code>mut</code>able, as the provided reference is the only handle to
it.</p>
<p>The macro syntax extends that of <code>vec!</code>. The simplest invocations are sequences
or repetitions of expressions, which can optionally be made <code>mut</code>able:</p>
<pre><code class="language-rust">use bitvec::prelude::*;

let r = bits![0, 1, 0, 1];
let w = bits![mut 0, 1, 0, 1];

let r2 = bits![static 1; 4];
let w2 = unsafe { bits![static mut 1; 4] };</code></pre>
<pre><code class="language-admonish info">You are not required to use the literals `0` or `1`; you can use any expression
that is `const`-evaluable and can be placed into the expression `expr != 0`.
This means that you cannot use the names of runtime `let` bindings, but can use
the names of `const` bindings, or other literals. You probably do not want to do
this, but you *can*.
</code></pre>
<p>In addition, you can specify the bit-ordering integer storage type parameters
for even more precise control over the memory layout. If you do not specify
them, the macro uses the default parameters of <code>usize</code> storage and <code>Lsb0</code>
ordering.</p>
<pre><code class="language-rust">use bitvec::prelude::*;

let in_bytes = bits![u8, LocalBits; 0, 1, 0, 1];
let in_shorts = bits![u16, Lsb0; 0, 1, 0, 1];
let in_ints = bits![mut u32, Msb0; 0; 4];</code></pre>
<p>To summarize the macro rules:</p>
<ul>
<li>If the first macro argument is <code>mut</code>, then the macro produces <code>&amp;mut BitSlice</code>,
otherwise it produces <code>&amp;BitSlice</code>. You do not need to bind the name as <code>mut</code>
unless you want to reässign it to a different slice.</li>
<li>You may then optionally provide the storage and ordering type parameters,
followed by a semicolon. You must provide either both or neither.</li>
<li>The data input to the macro is one of the two <code>vec!</code> token lists:
<ul>
<li>One or more expressions that can be placed into <code>$expr != 0</code>, separated by
commas. A trailing comma is permitted.</li>
<li>A single expression that can be placed into <code>$expr != 0</code>, followed by a
semicolon and a repetition counter. The resulting <code>BitSlice</code> will be
<code>counter</code> bits long, all set to <code>expression</code>.</li>
</ul>
</li>
</ul>
<pre><code class="language-admonish warning">Emulation tests indicate that `bitvec` correctly instructs the compiler to
produce suitable buffers even when compiling for a target with a different
byte-endianness than the host. However, I have not actually performed such
cross-compilation and testing with real hardware. It should be correct; please
file an issue if it is not.
</code></pre>
<h2 id="what-bitslice-can-do"><a class="header" href="#what-bitslice-can-do">What <code>BitSlice</code> Can Do</a></h2>
<p>Now that you have acquired a <code>BitSlice</code> reference, either by borrowing memory
from elsewhere in your program or by creating a temporary, it is time to do some
actual work with it.</p>
<h3 id="-that-bool-can"><a class="header" href="#-that-bool-can">… That <code>[bool]</code> Can</a></h3>
<p>Everything<sup class="footnote-reference" id="fr-1-1"><a href="#footnote-1">1</a></sup>. I am not going to rewrite the standard library’s slice
documentation here.</p>
<h3 id="-that-bool-cannot"><a class="header" href="#-that-bool-cannot">… That <code>[bool]</code> Cannot</a></h3>
<p>In addition to the standard library <code>[bool]</code> API, <code>BitSlice</code> offers some
inherent methods tailored to its specialization.</p>
<h3 id="set-queries"><a class="header" href="#set-queries">Set Queries</a></h3>
<p>The five query methods <code>.any()</code>, <code>.all()</code>, <code>.not_any()</code>, <code>.not_all()</code>, and
<code>.some()</code> test how many bits in a region are set to <code>1</code>. These methods have the
following truth table:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Slice</th><th style="text-align: center"><code>any</code></th><th style="text-align: center"><code>all</code></th><th style="text-align: center"><code>not_any</code></th><th style="text-align: center"><code>not_all</code></th><th style="text-align: center"><code>some</code></th></tr></thead><tbody>
<tr><td style="text-align: center"><code>00</code></td><td style="text-align: center"><code>false</code></td><td style="text-align: center"><code>false</code></td><td style="text-align: center"><code>true</code></td><td style="text-align: center"><code>true</code></td><td style="text-align: center"><code>false</code></td></tr>
<tr><td style="text-align: center"><code>01</code></td><td style="text-align: center"><code>true</code></td><td style="text-align: center"><code>false</code></td><td style="text-align: center"><code>false</code></td><td style="text-align: center"><code>true</code></td><td style="text-align: center"><code>true</code></td></tr>
<tr><td style="text-align: center"><code>11</code></td><td style="text-align: center"><code>true</code></td><td style="text-align: center"><code>true</code></td><td style="text-align: center"><code>false</code></td><td style="text-align: center"><code>false</code></td><td style="text-align: center"><code>false</code></td></tr>
</tbody></table>
</div>
<p><code>any</code> is the Boolean OR operator; <code>all</code> is the Boolean AND operator, and <code>some</code>
is the Boolean XOR operator.</p>
<p>In addition, <code>.count_ones()</code> and <code>.count_zeros()</code> count how many bits of the
slice are set to one or zero, rather than merely indicating whether any exist.
These methods are slower than the Boolean queries, which are capable of
short-circuiting once satisfied.</p>
<p>You can also use <code>.iter_ones()</code> and <code>.iter_zeros()</code> to walk each <em>index</em> of bits
with the specified value. These are equivalent to running <code>.filter()</code> and
<code>.enumerate()</code> calls on iterators of <code>bool</code>, but are specialized to use
dedicated bit-counting instructions where processors provide them.</p>
<h3 id="boolean-arithmetic"><a class="header" href="#boolean-arithmetic">Boolean Arithmetic</a></h3>
<p><code>bitvec</code> data structures all implement the Boolean operators (<code>&amp;</code>, <code>|</code>, <code>^</code>, and
<code>!</code>) against each other.</p>
<pre><code class="language-admonish warning">In version 0, they allowed any `impl Iterator&lt;Item = bool&gt;`. This has been
changed for performance reasons, since people never used the arbitrary iterator
support but did require improved behavior when operating on two bit-slices.

These still have performance degradations, as the conditions required to allow
specialized acceleration can be difficult to guarantee at either run- or
compile- time. We are working on it, but cannot make any promises.
</code></pre>
<pre><code class="language-rust">use bitvec::prelude::*;

let mut or  =  bits![mut 0, 0, 1, 1];
        or |=  bits![    0, 1, 0, 1];
assert_eq!(or, bits![    0, 1, 1, 1]);

let mut and  =  bits![mut 0, 0, 1, 1];
        and &amp;=  bits![    0, 1, 0, 1];
assert_eq!(and, bits![    0, 0, 0, 1]);

let mut xor  =  bits![mut 0, 0, 1, 1];
        xor ^=  bits![    0, 1, 0, 1];
assert_eq!(xor, bits![    0, 1, 1, 0]);

let mut not = bits![mut 0, 1];
        not = !not;
assert_eq!(not, bits![  1, 0]);</code></pre>
<h3 id="writing-to-memory"><a class="header" href="#writing-to-memory">Writing To Memory</a></h3>
<p>You can set all bits in a region to a new value by using the <code>.fill()</code> method,
or you can set one bit in a region to a new value by using either the <code>.set</code> or
<code>.get_mut</code> methods. <code>.get_mut</code> produces a proxy type which acts roughly like an
<code>&amp;mut bool</code> reference slot.</p>
<pre><code class="language-rust">use bitvec::prelude::*;

let bits = bits![0; 4];
assert!(bits.not_any());

bits[0 .. 1].set_all(true);
assert!(bits[0]);

bits.set(1, true);
assert!(bits[1]);

*bits.get_mut(2).unwrap() = true;
assert!(bits[2]);

let mut bit = bits.get_mut(3).unwrap();
assert!(!bit);
*bit = true;
assert!(bits[3]);

assert!(bits.all());</code></pre>
<p>The proxy type produced by <code>.get_mut()</code> implements <code>DerefMut&lt;Target = bool&gt;</code>, so
you can assign into it and read out of it. However, it does not commit the value
assigned into it back to its source <code>BitSlice</code> until it <code>Drop</code>s.</p>
<p>You can force the destruction of a named proxy reference by using its
<code>.commit()</code> method, which takes <code>self</code> by value, destroying it and releasing the
borrow.</p>
<pre><code class="language-admonish warning">The proxy type is *not* a reference, which means you need to bind it with
`let mut` in order to be able to write through it as if it were a reference.
</code></pre>
<h3 id="viewing-the-underlying-memory"><a class="header" href="#viewing-the-underlying-memory">Viewing the Underlying Memory</a></h3>
<p>The memory underlying any bit-slice region is subject to some restrictions about
aliasing that are documented more thoroughly in the <a href="https://docs.rs/bitvec/latest/bitvec/domain"><code>domain</code></a> module and the
<a href="bitvec/data-structures/../memory-model.html"><em>Memory Model</em> chapter</a>. In short, borrowed <code>BitSlice</code> regions cannot view
their underlying memory directly without violating aliasing rules established by
either the Rust language or by <code>bitvec</code> itself. Instead, the <code>.domain()</code> and
<code>.domain_mut()</code> methods provide views that correctly handle aliasing and edge
conditions, and mediate access to the underlying memory.</p>
<p>The owning handles (<code>BitArray</code>, <code>BitVec</code>, and <code>BitBox</code>) do not have this
limitation, as they can guarantee unique access to a memory location without any
possibility of aliasing. As such, <em>these</em> types all have <code>.as_raw_slice()</code> and
<code>.as_raw_mut_slice()</code> methods that provide ordinary slice views to their storage
region.</p>
<h2 id="footnotes"><a class="header" href="#footnotes">Footnotes</a></h2>
<hr>
<ol class="footnote-definition"><li id="footnote-1">
<p>Except write-assignment through indexing. I am not going to keep
mentioning this exception. <a href="#fr-1-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="arrays"><a class="header" href="#arrays">Arrays</a></h1>
<p>While <code>BitSlice</code> describes a region of borrowed data, <code>BitArray</code> provides a
container that can hold and manage such a region.</p>
<p>It is most comparable to the C++ type <a href="https://en.cppreference.com/w/cpp/utility/bitset" title="C++ std::bitset documentation"><code>std::bitset&lt;N&gt;</code></a>. Unfortunately, the
Rust support for type-level integers is still experimental, so it is unable to
take the length of the <code>BitSlice</code> it contains as a type parameter. Instead, it
must take the entire region it contains as a type parameter. The full type
declaration is</p>
<pre><code class="language-rust ignore"><span class="boring">use bitvec::prelude::*;
</span>pub struct BitArray&lt;
  A: BitViewSized,
  O: BitOrder,
&gt; {
  _ord: PhantomData&lt;O&gt;,
  data: A,
}</code></pre>
<p>As described in the <a href="bitvec/data-structures/./bitslice.html" title="BitSlice region">previous chapter</a>, the <code>BitView</code> trait is implemented on
the unsigned integers, and on arrays of them.</p>
<pre><code class="language-admonish info">Once type-level computation stabilizes, `BitArray` will change to have the type
parameters `&lt;T: BitStore, O: BitOrder, const N: usize&gt;`, matching the
`std::bitset&lt;N&gt;` length parameter. This will require a major-version increase.
</code></pre>
<p>This array dereferences to a <code>BitSlice</code> region over its entire length. It does
not currently permit shortening its <code>BitSlice</code> from either end. If this is a
behavior you want, please file an issue.</p>
<h2 id="declaring-a-bitarray-type"><a class="header" href="#declaring-a-bitarray-type">Declaring a <code>BitArray</code> Type</a></h2>
<p>Until Rust allows type-level integer computation to affect the memory layout,
<code>BitArray</code> types remain awkward to declare. You could declare types yourself by
using the <code>bitvec::mem::elts</code> function:</p>
<pre><code class="language-rust">use bitvec::{array::BitArray, mem, order::Lsb0};

type MyArray = BitArray&lt;[u8; mem::elts::&lt;u8&gt;(50)], Lsb0&gt;;</code></pre>
<p>But for convenience, we provide a <code>BitArr!</code> type-declaration macro. It expands
to exactly the expression above. It accepts the following syntaxes:</p>
<pre><code class="language-rust">use bitvec::{BitArr, order::Lsb0};

// explicit ordering
type A = BitArr!(for 50, in u16, Lsb0);
// implicit ordering defaults to Lsb0
type B = BitArr!(for 50, in u32);
// implicit store defaults to usize
type C = BitArr!(for 50);</code></pre>
<h2 id="creating-a-bitarray-value"><a class="header" href="#creating-a-bitarray-value">Creating a <code>BitArray</code> Value</a></h2>
<p>The <code>::ZERO</code> constant is a blank <code>BitArray</code> with its memory completely zeroed.
The <code>::new()</code> function wraps an existing element or array into a <code>BitArray</code>. In
addition, the macro constructor <code>bitarr!</code> takes the exact same arguments as the
<code>bits!</code> constructor, except that it returns an array directly rather than a
reference to a buffer.</p>
<p>Furthermore, <code>BitArray</code> structures and references can be constructed from
<code>&amp;BitSlice</code> references using the <code>TryFrom</code> trait, just as arrays can be
constructed in the standard library.</p>
<h2 id="using-a-bitarray"><a class="header" href="#using-a-bitarray">Using a <code>BitArray</code></a></h2>
<p>Once constructed, <code>BitArray</code> offers the <code>.as_bitslice()</code> and
<code>.as_mut_bitslice()</code> explicit methods, as well as all the standard traits, to
borrow its data as a <code>BitSlice</code>. The array has almost no functionality of its
own, and serves primarily to own a region used as a <code>BitSlice</code>. Like standard
library arrays, it natively produces a by-value iterator</p>
<p>Once you are done using <code>BitSlice</code> to manipulate the array, you can remove the
array with <code>.into_inner()</code> and regain the <code>A</code> memory within.</p>
<p>That’s everything that the array does! Like regular arrays, it is useful
primarily for its ability to move memory through a program, and has essentially
no behavior in its own right. As a plain data structure, it is most useful for
programs that do not have access to a dynamic allocator, and do not wish to use
<code>static</code> buffers. However, if you do have access to an allocator, you will
probably prefer to use <code>BitVec</code> instead.</p>
<p><code>BitArray</code> is uniquely suited as a structural field for types which implement
I/O protocols and have fixed-size buffers, such as the headers of internet
transport packets, or CPU instruction set encodings. A full example can be found
in the <a href="https://github.com/ferrilab/ferrilab/blob/main/bitvec/examples/ipv4.rs"><code>bitvec</code> examples</a>, but here is a short sample of how a TCP packet
header might be represented:</p>
<pre><code class="language-rust">use bitvec::prelude::*;

#[derive(Clone, Copy, Default)]
struct TcpHeader {
  data: BitArr!(for 160, in u8; Msb0),
}

impl TcpHeader {
  fn data_offset(&amp;self) -&gt; usize {
    self.data[96 .. 100].load::&lt;u8&gt;() as usize
  }

  fn set_data_offset(&amp;mut self, value: u8) {
    if !(5 ..= 15).contains(&amp;value) {
      panic!("invalid data offset value");
    }
    self.data[96 .. 100].store(value);
  }

  fn syn_flag(&amp;self) -&gt; bool {
    self.data[110]
  }

  fn sequence_number(&amp;self) -&gt; u32 {
    self.data[32 .. 64].load_be()
  }

  fn as_bytes(&amp;self) -&gt; &amp;[u8] {
    self.data.as_raw_slice()
  }
}</code></pre>
<p>This snippet shows how you can:</p>
<ul>
<li>use <code>BitArray</code> as the storage inside a semantic new-type</li>
<li>select individual flag bits</li>
<li>use sub-byte regions for small integer storage</li>
<li>use multi-byte regions for large integer storage</li>
<li>access the raw storage for interaction with I/O systems</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dynamic-allocations"><a class="header" href="#dynamic-allocations">Dynamic Allocations</a></h1>
<p><code>bitvec</code> has two types that require compiling the crate with <code>feature = "alloc"</code>
(and linking against the Rust distribution crate <code>alloc</code>): <code>BitVec</code> and
<code>BitBox</code>. <code>BitVec</code> is a dynamically resizable vector, equivalent to the C++ type
<a href="https://en.cppreference.com/w/cpp/container/vector_bool" title="C++ std::vector&lt;bool&gt; documentation"><code>std::vector&lt;bool&gt;</code></a> and the Rust type <a href="https://doc.rust-lang.org/stable/alloc/vec/struct.Vec.html" title="Vec API documentation"><code>Vec&lt;bool&gt;</code></a>. <code>BitBox</code> is a frozen
vector, incapable of changing its length, equivalent to the Rust type
<code>Box&lt;[bool]&gt;</code> or the C++ type <code>std::unique_ptr&lt;std::bitset&lt;N&gt;&gt;</code>.</p>
<p>Since <code>BitBox</code> is a vector that cannot <code>.push()</code> or <code>.pop()</code>, I will not discuss
it in detail here. It is a heap-allocated <code>BitSlice</code>, and is otherwise
uninteresting. It only exists because <code>Box&lt;BitSlice&gt;</code> is not expressible.</p>
<h2 id="getting-a-bitvec"><a class="header" href="#getting-a-bitvec">Getting a <code>BitVec</code></a></h2>
<p><code>BitVec</code> implements the constructors shown in the standard library: <code>::new()</code>
creates a handle without any allocation, <code>BitSlice</code> implements the
<code>.to_bitvec()</code> method, and and <code>ToOwned</code> trait, to copy a bit-slice into a new
bit-vector. Additionally, the <code>bitvec!</code> macro takes all the <code>bits!</code> arguments
and produces an owned allocation instead of a stack temporary. You can also
construct a <code>BitVec</code> by <code>.collect</code>ing any iterator of <code>bool</code>s.</p>
<pre><code class="language-rust">use bitvec::prelude::*;

let a: BitVec = BitVec::new();
let b = bits![0, 1, 0, 1].to_bitvec();
let c = bits![0; 4].clone();
let d = bits![u8, Msb0; 1; 4].to_owned();
let e = bitvec![0, 1, 1, 0];
let f = bitvec![u16, Msb0; 0; 4];
let g = [true, false, true, false]
  .iter() // &amp;bool
  .copied() // bool
  .collect::&lt;BitVec&gt;();</code></pre>
<h2 id="using-a-bitvec"><a class="header" href="#using-a-bitvec">Using a <code>BitVec</code></a></h2>
<p>Once constructed, <code>BitVec</code> implements the entire API that <code>Vec</code> does in the
standard library. This remains uninteresting to write out.</p>
<p>Like <code>BitSlice</code>, <code>BitVec</code> and <code>BitBox</code> are implemented as stack handles that use
the specially-encoded pointer to describe their region. This enables them to
remain the same size as their standard-library counterparts, while making them
completely opaque to inspection.</p>
<p>Because they are fully owned, <code>BitVec</code> and <code>BitBox</code> have some important
behavioral differences from <code>BitSlice</code>. Primarily, because they do not have to
worry about other handles viewing the memory under their control, they can
modify the contents of their buffers outside the <code>BitSlice</code> that is considered
live, and they do not exclude partial edge elements when viewing their buffer as
raw memory. If you are using <code>BitVec</code> to construct an I/O buffer, these two
facets can have surprising results if you are not careful to fully initialize a
memory span.</p>
<p>Vectors, like slices, do not need to begin at the zeroth index of the base
element. They can begin, and end, at any bit in any element. This will only
happen when copying a vector from a source slice that was misaligned. The
<code>.force_align()</code> method moves the vector’s live slice down to start at the zero
index. Once done, extending the live slice to reach the last index of an element
ensures that viewing the buffer as raw memory will have no uninitialized bits.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-parameters"><a class="header" href="#type-parameters">Type Parameters</a></h1>
<p><code>bitvec</code> uses type parameters to permit precise user control of its behavior and
in-memory representation. The Rust generic system permits <code>bitvec</code> to have a
more powerful and capable behavior than any other bitstream library yet
implemented in any language.</p>
<p>All <code>bitvec</code> types take two type parameters:</p>
<ol>
<li><code>T</code>: the storage type. The slice types (<code>BitSlice</code>, <code>BitVec</code>, <code>BitBox</code>)
select an unsigned integer, since as slices they store the length in their
runtime state. <code>BitArray</code> uses either a bare integer or an integer array as
its storage parameter, since it has no runtime state of its own and stores
all of its information in the type system.</li>
<li><code>O</code>: the ordering of bits within a single <code>T</code> element. We provide two
orderings, <code>Msb0</code> and <code>Lsb0</code>.</li>
</ol>
<p>The combination of these two type parameters governs how <code>bitvec</code> translates its
abstract storage (<code>usize -&gt; bool</code>) into real memory; if you do not care about
real-memory representation, then the default type parameters <code>&lt;usize, Lsb0&gt;</code>
will give you the best performance. If you do care about this, then the
<a href="bitvec/./memory-representation.html">memory representation</a> chapter goes into detail about all the combinations
and can help you select which one best fits your needs.</p>
<p>The <a href="https://docs.rs/bitvec/latest/bitvec/order/trait.BitOrder.html"><code>BitOrder</code></a> trait is open for third-party implementation. It describes its
requirements in great detail in its API documentation, so if you have a memory
representation that is neither <code>Lsb0</code> nor <code>Msb0</code>, you can implement the ordering
yourself and <code>bitvec</code> will use it without complaint.</p>
<hr />
<p>Rust syntax requires explicitly choosing type parameters when using generic
expressions, such as <code>BitVec::&lt;Store, Order&gt;::new()</code>, and will not substitute in
the default parameters when attempting to elide the parameters with
<code>BitVec::new()</code>. However, Rust <em>will</em> use the default type parameters in
patterns: <code>let bv: BitVec = BitVec::new();</code> will use the default type parameters
in the <code>: BitVec</code> type annotation, which then completes the type of the
expression on the right side of the assignment <code>=</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bit-ordering"><a class="header" href="#bit-ordering">Bit Ordering <!-- omit in toc --></a></h1>
<ol>
<li><a href="bitvec/type-parameters/bitorder.html#provided-orderings">Provided Orderings</a>
<ol>
<li><a href="bitvec/type-parameters/bitorder.html#lsb0"><code>Lsb0</code></a></li>
<li><a href="bitvec/type-parameters/bitorder.html#msb0"><code>Msb0</code></a></li>
<li><a href="bitvec/type-parameters/bitorder.html#localbits"><code>LocalBits</code></a></li>
<li><a href="bitvec/type-parameters/bitorder.html#default-ordering-parameter">Default Ordering Parameter</a></li>
</ol>
</li>
<li><a href="bitvec/type-parameters/bitorder.html#implementing-bitorder">Implementing <code>BitOrder</code></a>
<ol>
<li><a href="bitvec/type-parameters/bitorder.html#support-types">Support Types</a></li>
</ol>
</li>
</ol>
<p><code>bitvec</code> expects user code to count semantic indices, and hides the actual
position of a bit within a memory element from users. This allows user code to
treat indices as a uniform domain of integers in <code>0 ..= !0 &gt;&gt; 3</code>, and not have
to remember whether <code>place - 1</code> means moving “forward” or “backward” in the
buffer.</p>
<p>Internally, each <code>*BitSlice</code> pointer contains an element address and a bit
index. The pointer uses its <code>BitOrder</code> type parameter to translate the bit index
into a mask that drives actual memory access.</p>
<p><code>BitOrder</code> is open to user implementation, and implementations of it are trusted
to be sound in the <code>bitvec</code> memory model. For this reason, the trait is <code>unsafe</code>
to implement. Most users will not implement it; almost all users want one of the
two monotonic orderings provided for you. However, some specialized users may
have an ordering of their own, and they are still able to encode that ordering
away from their index logic.</p>
<h2 id="provided-orderings"><a class="header" href="#provided-orderings">Provided Orderings</a></h2>
<p><code>bitvec</code> provides two orderings: <a href="https://docs.rs/bitvec/latest/bitvec/order/struct.Lsb0.html"><code>Lsb0</code></a> and <a href="https://docs.rs/bitvec/latest/bitvec/order/struct.Msb0.html"><code>Msb0</code></a>. These each refer to
which numeric bit in a register element is considered to be the zero-index.</p>
<p>You can think of these as corresponding to the little-endian and big-endian
processor byte orderings if you like, as long as you remember that your choice
of bit-ordering is not at all related to the byte-ordering of your target
processor.</p>
<h3 id="lsb0"><a class="header" href="#lsb0"><code>Lsb0</code></a></h3>
<p>The <code>Lsb0</code> type sets the zero index at the least significant bit of a register
(numeric value 1) and each successive index selects the next more significant
bit in the register, until the most significant bit is at the final index.</p>
<p>It is the expression <code>mask = 1 &lt;&lt; index;</code>.</p>
<h3 id="msb0"><a class="header" href="#msb0"><code>Msb0</code></a></h3>
<p>The <code>Msb0</code> type sets the zero index at the most significant bit of a register
(numeric value 2<sup>n</sup> - 1 for an <code>n</code>-bit register) and each successive
index selects the next less significant bit in the register, until the least
significant bit is at the final index.</p>
<p>It is the expression <code>mask = (iN::MIN as uN) &gt;&gt; index;</code>.</p>
<h3 id="localbits"><a class="header" href="#localbits"><code>LocalBits</code></a></h3>
<p>The type alias <code>LocalBits</code> refers to the ordering that your target’s C compiler
will likely choose for its bitfield direction. This is <code>Lsb0</code> on little-endian
byte-ordered processors, and <code>Msb0</code> on big-endian byte-ordered processors.
Remember that the <code>BitOrder</code> implementations and processor byte orderings have
no relation to each other! This is only a custom, not a requirement of the
processor architecture.</p>
<h3 id="default-ordering-parameter"><a class="header" href="#default-ordering-parameter">Default Ordering Parameter</a></h3>
<p><code>Lsb0</code> is the default type parameter used by the sequence types, as it produces
selection masks using the starting value <code>1</code>, which encodes to smaller
instructions than the <code>Msb0</code> starting value.</p>
<p>On AMD64, the pairs <code>&lt;u64, Lsb0&gt;</code> and <code>&lt;u64, Msb0&gt;</code> produce the following object
code and disassembly:</p>
<pre><code class="language-text">ba 01 00 00 00  movl $1, %edx
48 d3 e2        shlq %cl, %rdx

48 ba 00 00 00 00 00 00 00 80  movabsq $-9223372036854775808, %rdx
48 d3 ea                       shrq    %cl, %rdx
</code></pre>
<p>The <code>Msb0</code> load requires an additional four bytes of zeros in its immediate,
and the 64-bit modifier prefix (<code>0x48</code>), in order to encode <code>movabsq</code> instead of
<code>movl</code></p>
<h2 id="implementing-bitorder"><a class="header" href="#implementing-bitorder">Implementing <code>BitOrder</code></a></h2>
<p>As stated above, this is an <code>unsafe trait</code> because <code>bitvec</code> relies on its
implementations to uphold certain mathematical invariants. Failure will result
in memory unsafety and/or program crashes.</p>
<p><code>BitOrder</code> has three functions: <code>at</code>, <code>select</code>, and <code>mask</code>. Implementors are
required to provide <code>at</code>; <code>select</code> and <code>mask</code> have default implementations that
rely on it. These functions are all generic over the <code>BitMemory</code> trait; this
trait describes the register types (unsigned integers) that can be used by
<code>bitvec</code>. It provides some useful associated constants, and is otherwise
uninteresting.</p>
<ul>
<li>
<p><a href="https://docs.rs/bitvec/latest/bitvec/order/trait.BitOrder.html#tymethod.at"><code>::at()</code></a> receives the semantic index of a bit within a register type, and
must produce the concrete position corresponding to the semantic index. The
input and output are both integers in the domain <code>[0, W)</code> where <code>W</code> is the
bit-width of the register type being indexed.</p>
<p><code>at</code> <strong>must</strong> implement an exactly one-to-one mapping from all inputs to all
outputs in the <code>[0, W)</code> domain. This mapping must never observably change.
These are strict requirements of the library, and failing to uphold either
<strong>will</strong> break your program.</p>
</li>
<li>
<p><a href="https://docs.rs/bitvec/latest/bitvec/order/trait.BitOrder.html#method.select"><code>::select()</code></a> receives the semantic index of a bit within a register type,
and must produce a value of that register type with exactly one bit set. The
produced value is a mask that selects only the bit specified by the provided
index, and will be used in Boolean arithmetic to manipulate memory.</p>
<p>The default implementation is <code>1 &lt;&lt; at(index)</code>. You are required to maintain
this behavior in your override.</p>
</li>
<li>
<p><a href="https://docs.rs/bitvec/latest/bitvec/order/trait.BitOrder.html#method.mask"><code>::mask()</code></a> receives an inclusive start index and an exclusive end index, and
must produce a register value that selects every bit in the indexed range.</p>
<p>The default implementation is <code>(start .. end).map(select).sum()</code>. You are
required to maintain this behavior in your override.</p>
</li>
</ul>
<h3 id="support-types"><a class="header" href="#support-types">Support Types</a></h3>
<p>The <code>BitOrder</code> trait APIs use supporting types to enforce requirements on the
bare numbers being passed through it. These types are documented in the
<a href="https://docs.rs/bitvec/latest/bitvec/index/index.html"><code>index</code></a> module. They all provide a <code>.value()</code> method that removes the wrapper
and yields the inner number, and a <code>::new()</code> constructor that ensures that
values to be wrapped uphold the type’s requirements.</p>
<ul>
<li><code>at</code> and <code>select</code> receive a <a href="https://docs.rs/bitvec/latest/bitvec/index/struct.BitIdx.html"><code>BitIdx&lt;M&gt;</code></a> argument. This is a wrapper over
<code>u8</code> that ensures that the contained value is in the domain <code>0 .. M::BITS</code>. It
serves to indicate that a number is a semantic counter, not an electrical
position.</li>
<li><code>at</code> returns a <a href="https://docs.rs/bitvec/latest/bitvec/index/struct.BitPos.html"><code>BitPos&lt;M&gt;</code></a> value. This has the same behavior and
restrictions as <code>BitIdx&lt;M&gt;</code>, and indicates that the number is an electrical
position within a register.</li>
<li><code>select</code> returns a <a href="https://docs.rs/bitvec/latest/bitvec/index/struct.BitSel.html"><code>BitSel&lt;M&gt;</code></a> value. This wraps an <code>M</code> register value, and
ensures that the contained number is a power of two – exactly one bit is set,
and all others are zero. This type indicates that the mask is guaranteed to
select exactly one bit in a register.</li>
<li><code>mask</code> receives an inclusive <code>BitIdx&lt;M&gt;</code> and an exclusive <a href="https://docs.rs/bitvec/latest/bitvec/index/struct.BitEnd.html"><code>BitEnd&lt;M&gt;</code></a>
argument, and returns a <a href="https://docs.rs/bitvec/latest/bitvec/index/struct.BitMask.html"><code>BitMask&lt;M&gt;</code></a> value. <code>BitEnd&lt;M&gt;</code> ensures that the
contained number is in the domain <code>0 ..= M::BITS</code>, including the final count,
and marks a one-past-the-end exclusive boundary. <code>BitMask&lt;M&gt;</code> marks that the
contained number may select any number of bits in a register.</li>
</ul>
<p>New implementors of <code>BitOrder</code> will use these types to satisfy behavior
requirements individually.</p>
<p>In addition, implementors’ test suites should call the function
<code>order::verify_for_type::&lt;O, M&gt;()</code> to check that an implementation <code>O</code> satisfies
the behavior requirements for a particular register type <code>M</code>, or call
<code>order::verify::&lt;O&gt;()</code> to check that an implementation satisfies the behavior
requirements for <em>all</em> supported register types. These functions are conditional
upon <code>cfg(test)</code>, and accept a <code>verbose: bool</code> parameter that allows the test
functions to print diagnostics to <code>stdout</code> during evaluation.</p>
<p>If the verification functions panic, your implementation is incorrect, and
cannot be safely used in <code>bitvec</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bit-storage-within-registers"><a class="header" href="#bit-storage-within-registers">Bit Storage Within Registers</a></h1>
<p>The <a href="https://docs.rs/bitvec/latest/bitvec/store/trait.BitStore.html"><code>BitStore</code></a> trait governs the processor behaviors used to interact with the
memory of a <code>BitSlice</code> buffer. These include both the width of the processor
register used to contain a memory element, and the load/store instructions the
processor uses to move data across the memory bus.</p>
<p><code>BitStore</code> has no behavior of its own, and serves only to collect associated
types and constants. It cannot be implemented outside <code>bitvec</code>, and is a closed
portion of the API. You can freely use the trait as a bound in types that
contain <code>bitvec</code> structures, but should not otherwise attempt to make use of it.</p>
<h2 id="implementations"><a class="header" href="#implementations">Implementations</a></h2>
<p><code>BitStore</code> is implemented on all unsigned integer types not larger than a target
processor’s word size, all <code>Cell&lt;T&gt;</code> wrappers of them (as <code>Cell</code> is a compiler
directive), and their <code>AtomicT</code> variants.</p>
<p>Not all processors have atomic instructions for all their scalar registers.
<code>bitvec</code> uses the [<code>radium</code>] crate to manage its support for atomic types.</p>
<p>On architectures with missing atomics, <code>bitvec</code>’s default feature set will cause
a compiler error when you attempt to instantiate a <code>bitvec</code> structure with the
register that is missing an atomic variant. You can fix this by using a narrower
register that does have atomic instructions, or by disabling <code>default-features</code>
and not enabling the <code>"atomic"</code> feature.</p>
<h2 id="associated-types"><a class="header" href="#associated-types">Associated Types</a></h2>
<p>The <code>Mem</code> associated type names the scalar integer corresponding to the
<code>BitStore</code> type. <code>u8</code>, <code>Cell&lt;u8&gt;</code>, and <code>AtomicU8</code> all implement <code>BitStore</code> with
their <code>Mem</code> type assigned as <code>u8</code>; the same is true for the wider registers.</p>
<p>This type is used to create selection masks in the processor and permit access
to unaliased memory.</p>
<p>The <code>Access</code> associated type names the type used to implement memory access. The
<code>BitAccess</code> trait is an internal bridge to <code>Radium</code> that allows a consistent
memory API, regardless of instructions used. All reads from and writes to memory
route through this association and trait.</p>
<p>Lastly, the <code>Alias</code> and <code>Unalias</code> associated types enable <code>bitvec</code> to gracefully
and correctly handle events that cause multiple handles to alias the same memory
address. This association is used in <code>.split_at_mut()</code> to select the alias-aware
type used for all subsequent accesses.</p>
<p>The <code>Mem</code> and <code>Alias</code> types are exposed in public APIs according to local alias
information. The <code>Access</code> type is never publicly exposed, and only used for code
generation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="practical-use"><a class="header" href="#practical-use">Practical Use</a></h1>
<p>That’s enough theory; let’s talk about how to use the crate. This chapter is
divided into two subsections, one for use cases that want an ordinary <code>bool</code>
collection library with transparent memory compaction, and one for use cases
that want a convenient way to precisely sculpt memory. Before getting in to
either, let’s quickly recap how the <code>bitvec</code> types interact with memory
ownership.</p>
<h2 id="rustic-memory-management"><a class="header" href="#rustic-memory-management">Rustic Memory Management</a></h2>
<p>The first and most important thing to remember is that, despite the extra
complexity just discussed about memory parameters and aliasing behavior,
<code>bitvec</code> is <em>just Rust</em>. It obeys all of the rules and patterns that the rest of
Rust does.</p>
<p><code>BitSlice</code>s, like regular slices, are exclusively borrowed from owned memory
higher up the call stack. Their references can be passed down the stack, and are
subject to the same lifetime and mutation-exclusivity rules.</p>
<p>The owned memory that creates a <code>BitSlice</code> view can be an array, boxed slice, or
vector of either ordinary integers, or their wrapper equivalents provided by
<code>bitvec</code>:</p>
<pre><code class="language-rust">use bitvec::prelude::*;

let array = [0u8; 8];
let boxed: Box&lt;[u16]&gt; = Box::new([0u16; 4]);
let vec = vec![0u32; 2];

let bits_a = bitarr![u8, Msb0; 0; 64];
let bits_b = bitbox![u16, Lsb0; 0; 64];
let bits_v = bitvec![u32, LocalBits; 0; 32];</code></pre>
<p>Once memory is bound, it can be borrowed as a <code>BitSlice</code> by using the <code>BitView</code>
trait (imported in the prelude), or by using the fact that all <code>bitvec</code>
containers borrow themselves as <code>BitSlices</code> just like standard-library
containers borrow themselves as slices:</p>
<pre><code class="language-rust"><span class="boring">use bitvec::prelude::*;
</span><span class="boring">let array = [0u8; 8];
</span><span class="boring">let boxed: Box&lt;[u16]&gt; = Box::new([0u16; 4]);
</span><span class="boring">let vec = vec![0u32; 2];
</span><span class="boring">let bits_a = bitarr![u8, Msb0; 0; 64];
</span><span class="boring">let bits_b = bitbox![u16, Lsb0; 0; 64];
</span><span class="boring">let bits_v = bitvec![u32, LocalBits; 0; 32];
</span>let array_bits = array.view_bits::&lt;Msb0&gt;();
let boxed_bits = boxed.view_bits::&lt;Lsb0&gt;();
let vec_bits = vec.view_bits::&lt;LocalBits&gt;();

let bits_a_ref: &amp;BitSlice&lt;_, _&gt; = &amp;bits_a;
let bits_b_ref: &amp;BitSlice&lt;_, _&gt; = &amp;bits_b;
let bits_c_ref: &amp;BitSlice&lt;_, _&gt; = &amp;bits_c;</code></pre>
<blockquote>
<p>And, of course, mutability applies:</p>
<pre><code class="language-rust">let mut arr = bitarr![0; 10];
let arr_ref: &amp;mut BitSlice = &amp;mut arr;
arr_ref.set(1, true);
assert!(arr_ref[1]);</code></pre>
</blockquote>
<p>Just as with ordinary Rust code, <code>BitSlice</code> is the type you want to use when
working with memory that you are not responsible for moving around or
destroying. However, when you do need to move memory around, you need to switch
to either a <code>static</code> binding or a container: <code>BitArray</code> is always available, and
<code>BitBox</code> and <code>BitVec</code> require an allocator.</p>
<p>I am spending this much time discussing the Rust memory management system
because this is a <em>very</em> common question I receive. No other bit-stream crate
has reference types, and therefore users coming from, e.g., <code>bit-vec</code> see the
same <code>BitSlice</code> name and attempt to use their habits from that crate.</p>
<p><code>bitvec</code> is not like any other bitstream library, in Rust, C++, or another
language. <code>bitvec</code> is like ordinary Rust. I promise.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bit-collections"><a class="header" href="#bit-collections">Bit Collections</a></h1>
<p>As discussed in the <a href="bitvec/practical-use/../type-parameters.html">Type Parameters</a> chapter, you should use <code>usize</code> as the
<code>BitStore</code> parameter for optimal performance in the generated program.</p>
<p>Once you have created some memory that you can view as individual bits, it is
time to actually use it. Here is the one-sentence summary of what <code>bitvec</code> can
do:</p>
<blockquote>
<p>Every stable API present in the standard library is replicated in <code>bitvec</code>,
except for <code>BitSlice&lt;T, O&gt; as IndexMut&lt;usize&gt;</code>, because <code>bitvec</code> cannot
produce <code>&amp;mut bool</code>.</p>
</blockquote>
<p>If you were using ordinary collections to manage sequences of <code>bool</code>s, then
every part of your code will continue to work on <code>bitvec</code> types except for the
array assignment <code>slice[index] = value;</code>. Until and unless the <code>IndexMut</code> trait
is reshaped, you will need to use one of these two alternatives:
<code>slice.set(index, value);</code> or <code>*slice.get_mut(index).unwrap() = value;</code></p>
<p>Subslicing works:</p>
<pre><code class="language-rust">use bitvec::prelude::*;

let bits = bits![0, 0, 0, 0, 1, 1, 1, 1];
assert!(bits[.. 4].not_any());
assert!(bits[4 ..].all());</code></pre>
<p>Incremental munching works:</p>
<pre><code class="language-rust">use bitvec::prelude::*;

let mut bits = bits![0, 0, 1, 1, 1, 0, 0, 0];
//  ^^^ modify the slice handle, not the slice contents

while let Some((&amp;false, rest)) = bits.split_first() {
  bits = rest;
}
assert_eq!(bits, bits![1, 1, 1, 0, 0, 0]);

while let Some((&amp;false, rest)) = bits.split_last() {
  bits = rest;
}
assert_eq!(bits, bits![1; 3]);</code></pre>
<p>Mutation works:</p>
<pre><code class="language-rust">use bitvec::prelude::*;
use std::{iter, thread};

let bits: &amp;'static mut BitSlice = bits![mut 0; 8];

{
  let (left, right) = bits.split_at_mut(4);

  //  Pretend that better work is happening here
  let a = thread::spawn(|| left |= iter::repeat(true));
  let b = thread::spawn(|| right ^= iter::repeat(true));

  a.join().unwrap();
  b.join().unwrap();
}

assert_eq!(bits, bits![1; 8]);</code></pre>
<p>Everything you can do with a slice, an array, or a vector of bits, you can do
with <code>bitvec</code>’s equivalent types. Except for <code>IndexMut&lt;usize&gt;</code>. The only change
from the standard library types is that you are now guaranteed to use one bit of
storage for each bit of information, rather than eight bits of storage per bit.</p>
<pre><code class="language-admonish info">Author’s note: Other than bragging about `bitvec`’s API fidelity, I don’t think
this section is very useful or educational. If you want to read more about how
to use `bitvec` for `usize =&gt; bool` collections, please let me know and I will
expound!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bitfields"><a class="header" href="#bitfields">Bitfields</a></h1>
<p><code>bitvec</code>’s more technically-interesting capability is that it provides
load/store memory access behaviors that allow you to write values into, and read
them back out of, any <code>BitSlice</code> in memory rather than being constrained to
well-formed references to well-typed memory.</p>
<p>This is useful for the de/construction of packed memory buffers, such as
transporting data through I/O protocols.</p>
<pre><code class="language-admonish warning">**AUTHOR’S NOTE**: If you are using `bitvec` to do **anything** related to the
underlying memory representation of a bit-buffer, you **must** read this
chapter, and **all** of the API docs of [`bitvec::field`] and its contents,
**in their entirety**.

I have written extensively, and yet still insufficiently, about the intricacies
involved in operating the `BitField` trait correctly. If you skim this
documentation, you *will* have unexpected behavior, you *will* get frustrated
with me for writing a bad library, you *will* file an issue about it, and I will
*probably* tell you that the behavior is correct and that I already addressed it
in the documentation.

It took me a long time to think about and a long time to write. It should take
you *also* a long time to read and a long time to think about.
</code></pre>
<p>All of this behavior is contained in the <code>BitField</code> trait. Let’s explore that:</p>
<pre><code class="language-rust no_run">//  bitvec::field

pub trait BitField {
  fn load&lt;M&gt;(&amp;self) -&gt; M;
  fn store&lt;M&gt;(&amp;mut self, value: M);
}

impl&lt;T&gt; BitField for BitSlice&lt;T, Lsb0&gt; {
  fn load&lt;M&gt;(&amp;self) -&gt; M { /* snip */ }
  fn store&lt;M&gt;(&amp;mut self, value: M) { /* snip */ }
}

impl&lt;T&gt; BitField for BitSlice&lt;T, Msb0&gt; {
  fn load&lt;M&gt;(&amp;self) -&gt; M { /* snip */ }
  fn store&lt;M&gt;(&amp;mut self, value: M) { /* snip */ }
}</code></pre>
<p>The actual trait is more complex than this, and will be visited later. The
important part, right now, is that <code>BitField</code> allows you to load values out of
<code>BitSlice</code>s and store values into them. Furthermore, it is implemented
<em>specifically</em> on <code>BitSlices</code> that use the bit orderings provided by <code>bitvec</code>,
and is <strong>not</strong> generic over all orderings.</p>
<p>While <code>bitvec</code> could in theory provide a default implementation for all
<code>&lt;O: BitOrder&gt;</code>, this would by necessity have the most pessimal possible
performance, and the lack of specialization for overlapping trait
implementations means that faster performance can never be written.</p>
<p>The downside of the two specific implementations is that Rust <em>coherence</em> rules
forbid implementation of a <code>bitvec</code> trait, on a <code>bitvec</code> type, parameterized
with a local, but non-<code>bitvec</code>, implementor of <code>BitOrder</code>. On the off chance
that you find yourself writing a new <code>BitOrder</code> implementor, file an issue.</p>
<p>The <code>M</code> type parameter on the load and store methods is bounded by funty’s
<code>Integral</code>, trait. It can store any unsigned <em>or signed</em> integer at any partial
width. This parameterization allows you to combine any integer type for transfer
with any integer type for storage, rather than being restricted to only
transferring <code>T</code> data into and out of a <code>BitSlice&lt;T, _&gt;</code>.</p>
<p>Unfortunately, adding a second integer type parameter is not the only
complication to the <code>BitStore</code> memory model. There is also a second dimension of
segment ordering. <code>bitvec</code> tries to make explicitly clear that the <code>Lsb0</code> and
<code>Msb0</code> types refer only to the ordering of <em>bits</em> within registers, and not to
the ordering of <em>bytes</em> within registers. However, when the integer bit-sequence
being stored or stored does not fit within one register of the storage
<code>BitSlice</code>, it must be split into multiple segments, and those segments must
somehow be ordered in memory.</p>
<h2 id="segment-orderings"><a class="header" href="#segment-orderings">Segment Orderings</a></h2>
<pre><code class="language-admonish warning">Author’s Note: **READ THIS**. I have received *several* issues about this exact
concept. *It is not obvious*.
</code></pre>
<p>There are two segment orderings: little-endian and big-endian. You may select
the segment endianness you prefer by using the <code>_le</code> or <code>_be</code> suffix,
respectively, on the <code>.load()</code> and <code>.store()</code> methods. The unsuffixed method is
an alias for the endianness of your processor: <code>_be</code> on big-endian targets, and
<code>_le</code> on little-endian. This is a <strong>convenience only</strong>. If you are writing I/O
buffers, you should really use the explicitly-named methods.</p>
<p>Let us imagine a <code>BitSlice&lt;u8, Lsb0&gt;</code> used to store a <code>u16</code> that is misaligned,
and thus stored in three successive bytes. This algorithm is true for all
circumstances where the stored region occupies more than one register of the
backing slice, but smaller examples are simpler to draw.</p>
<p>This diagram uses <code>0</code> to refer to the least significant bit, and <code>7</code> to refer to
the most significant bit. The first row shows bytes of memory, the second row
shows the bit indices in memory used by <code>.store_le()</code>, and the third row shows
the bit indices in memory used by <code>.store_be()</code>.</p>
<pre><code class="language-text">[ 7 6 5 4 3 2 1 0 ] [ 7 6 5 4 3 2 1 0 ] [ 7 6 5 4 3 2 1 0 ]
  3 2 1 0             b a 9 8 7 6 5 4             f e d c
  f e d c             b a 9 8 7 6 5 4             3 2 1 0
</code></pre>
<p><code>.store_le()</code> places the least significant segment in the low address, while
<code>.store_be()</code> places the most significant segment in the low address. The
ordering of bits within a segment is <em>always</em> preserved, no matter which
ordering parameter is used by the <code>BitSlice</code>.</p>
<p>Here is the same example, but using the <code>Msb0</code> bit ordering instead. Again, the
second row uses <code>.store_le()</code>, and the third row uses <code>.store_be()</code>.</p>
<pre><code class="language-text">[ 7 6 5 4 3 2 1 0 ] [ 7 6 5 4 3 2 1 0 ] [ 7 6 5 4 3 2 1 0 ]
          3 2 1 0     b a 9 8 7 6 5 4     f e d c
          f e d c     b a 9 8 7 6 5 4     3 2 1 0
</code></pre>
<p>The only change is in how the segments are placed into memory. The ordering of
bits within a segment never changes, and is always the processor’s significance
order as implemented in hardware.</p>
<h2 id="how-to-use-bitfield"><a class="header" href="#how-to-use-bitfield">How to Use <code>BitField</code></a></h2>
<p>You will probably find real use of the <code>BitField</code> trait more educational than
the previous section. It has a very straightforward API, that you can combine
with <code>println!</code>-debugging or your favorite means of viewing memory in order to
observe its actions.</p>
<p>Step one: create any <code>BitSlice</code>-capable buffer. This can be any of the
Rust-native sequence types, or any of the <code>bitvec</code> types.</p>
<pre><code class="language-rust">use bitvec::prelude::*;

let mut data = [0u8; 4];
let bits = data.view_bits_mut::&lt;Msb0&gt;();</code></pre>
<p>Then, narrow the <code>BitSlice</code> to be the region you want to access as storage. It
must be no wider than the integer type you are transferring: <code>BitSlice</code>s whose
length is outside the domain <code>1 ..= M::BITS</code> will panic during <code>.load()</code> or
<code>.store()</code>. The easiest way to narrow a <code>BitSlice</code> (or buffer type that
dereferences to it) is by using range indexing, <code>[start .. end]</code>.</p>
<pre><code class="language-rust"><span class="boring">use bitvec::prelude::*;
</span><span class="boring">let bits = bits![mut u8, Msb0; 0; 32];
</span>bits[10 ..][.. 13].store_be::&lt;u16&gt;(0x765);
assert_eq!(bits[10 .. 23].load_be::&lt;u16&gt;(), 0x765);

bits[10 .. 23].store_le::&lt;u16&gt;(0x432);
assert_eq!(bits[10 .. 23].load_le::&lt;u16&gt;(), 0x432);</code></pre>
<p>That’s the entire API. <code>.store()</code> truncates the stored value to the width of the
receiving <code>BitSlice</code>, and <code>.load()</code> sign-extends the loaded value to the width
of the destination register type.</p>
<pre><code class="language-admonish danger">Storing signed integers can be surprisingly fraught: `bitvec` **will not**
attempt to detect and preserve the most-significant sign bit when truncating! If
you store the number `-12i8` (`0b1111_0100`) in a 4-bit slot, it will be stored
as `4i8` and reloaded as such! Similarly, storing `12i8` (`0b0000_1100)` in a
4-bit slot will produce a load of `-4i8` (`0b1111_1100`).

Signed integers do not behave like unsigned integers. You are wholly responsible
for ensuring that you remember that allowing negative numbers halves the
magnitude: 4 bits unsigned is `0 .. 16`, but 4 bits signed is `-8 .. 8`.

`bitvec` **only stores bit patterns**. Retaining numerical intelligibility is
**your** responsibility.
</code></pre>
<p>You can see an example that uses the <code>BitField</code> trait to implement an I/O
protocol in the <code>examples/ipv4.rs</code> program in the repository. Use
<code>cargo run --example ipv4</code> to see it in action.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="memory-representation"><a class="header" href="#memory-representation">Memory Representation</a></h1>
<p>As discussed in the <em>Type Parameters</em> chapter, <code>bitvec</code> allows users to select
the specific ordering of bits within a memory element when constructing a type.
This has consequences for how source code translates to an in-memory
representation.</p>
<p>To review: <code>bitvec</code> provides two orderings of bits within a single memory
element (<code>Lsb0</code> and <code>Msb0</code>) and three or four types of memory elements (<code>u8</code>,
<code>u16</code>, <code>u32</code>, and only on systems where it is 8-byte-aligned, <code>u64</code>). The
<code>usize</code> type is also supported, but it is not portable, and behaves exactly as
the named register of its width.</p>
<pre><code class="language-admonish info">The `Cell` and atomic integer variants are not interesting here, as they only
affect how the memory bus operates, not the processor register.
</code></pre>
<p>Let us now examine how each possible combination of register width,
bit-ordering, <strong>and processor byte endianness</strong> affects the placement of bits in
memory.</p>
<h2 id="memory-layout"><a class="header" href="#memory-layout">Memory Layout</a></h2>
<p>The <code>BitOrder</code> and <code>BitStore</code> traits combine with your target architecture’s
byte-ordering of register elements to create a matrix of memory traversals. This
matrix informs what is the appropriate choice of parameters to use for your
program whenever you are using <code>bitvec</code> for precise memory control rather than
solely for a compact <code>usize</code>-to-<code>bool</code> data collection.</p>
<p>The tables below list bytes of a memory address space with addresses increasing
to the right, and the bits <em>within</em> those bytes with numeric significance
decreasing to the right. This is the ordering used in most debug-printing of
memory, so hopefully the table contents should match up with your prior
experience viewing memory bytes.</p>
<p>The <code>L</code> and <code>M</code> indicate the <code>Lsb0</code> and <code>Msb0</code> ordering parameters,
respectively, and <code>xx</code> indicates that the row matches all register types.
Within each row, traversal begins at zero and follows the arrows to each
successive step. Boundaries between registers are marked with a column;
boundaries between bytes within the same register are marked with a space.</p>
<h3 id="little-endian-byte-ordered-machines"><a class="header" href="#little-endian-byte-ordered-machines">Little-Endian Byte-Ordered Machines</a></h3>
<p>On little-endian machines, the least-significant <em>byte</em> of a register type is
stored at the lowest memory address, and each byte-address higher is one step
more numerically significant than the last.</p>
<pre><code class="language-text">byte ║ 00000000│11111111│22222222│33333333│44444444│55555555│66666666│77777777
bit  ║ 76543210│76543210│76543210│76543210│76543210│76543210│76543210│76543210
═════╬═════════╪════════╪════════╪════════╪════════╪════════╪════════╪════════
 Lxx ║ 1 &lt;--- 0│3 &lt;--- 2│5 &lt;--- 4│7 &lt;--- 6│9 &lt;--- 8│B &lt;--- A│D &lt;--- C│F &lt;--- E
─────╫─────────┼────────┼────────┼────────┼────────┼────────┼────────┼────────
 M8  ║ 0 ---&gt; 1│2 ---&gt; 3│4 ---&gt; 5│6 ---&gt; 7│8 ---&gt; 9│A ---&gt; B│C ---&gt; D│E ---&gt; F
 M16 ║ 2 ---&gt; 3 0 ---&gt; 1│6 ---&gt; 7 4 ---&gt; 5│A ---&gt; B 8 ---&gt; 9│E ---&gt; F C ---&gt; D
 M32 ║ 6 ---&gt; 7 4 ---&gt; 5 2 ---&gt; 3 0 ---&gt; 1│E ---&gt; F C ---&gt; D A ---&gt; B 8 ---&gt; 9
 M64 ║ E ---&gt; F C ---&gt; D A ---&gt; B 8 ---&gt; 9 6 ---&gt; 7 4 ---&gt; 5 2 ---&gt; 3 0 ---&gt; 1
</code></pre>
<h3 id="big-endian-byte-ordered-machines"><a class="header" href="#big-endian-byte-ordered-machines">Big-Endian Byte-Ordered Machines</a></h3>
<p>On big-endian machines, the most-significant <em>byte</em> of a register type is stored
at the lowest memory address, and each byte-address higher is one step less
numerically significant than the last.</p>
<pre><code class="language-text">byte ║ 00000000│11111111│22222222│33333333│44444444│55555555│66666666│77777777
bit  ║ 76543210│76543210│76543210│76543210│76543210│76543210│76543210│76543210
═════╬═════════╪════════╪════════╪════════╪════════╪════════╪════════╪════════
 L8  ║ 1 &lt;--- 0│3 &lt;--- 2│5 &lt;--- 4│7 &lt;--- 6│9 &lt;--- 8│B &lt;--- A│D &lt;--- C│F &lt;--- E
 L16 ║ 3 &lt;--- 2 1 &lt;--- 0│7 &lt;--- 6 5 &lt;--- 4│B &lt;--- A 9 &lt;--- 8│F &lt;--- E D &lt;--- C
 L32 ║ 7 &lt;--- 6 5 &lt;--- 4 3 &lt;--- 2 1 &lt;--- 0│F &lt;--- E D &lt;--- C B &lt;--- A 9 &lt;--- 8
 L64 ║ F &lt;--- E D &lt;--- C B &lt;--- A 9 &lt;--- 8 7 &lt;--- 6 5 &lt;--- 4 3 &lt;--- 2 1 &lt;--- 0
─────╫─────────┬────────┬────────┬────────┬────────┬────────┬────────┬────────
 Mxx ║ 0 ---&gt; 1│2 ---&gt; 3│4 ---&gt; 5│6 ---&gt; 7│8 ---&gt; 9│A ---&gt; B│C ---&gt; D│E ---&gt; F
</code></pre>
<hr />
<p>If you need to care about the memory representation, then you <em>most likely</em> want
to use the <code>&lt;u8, Msb0&gt;</code> pair. This provides a consistent ordering on all
machines, and the numeric value of the underlying memory will probably match
your expectations about the semantic contents of a data structure.</p>
<p>This chapter, and the <a href="https://docs.rs/bitvec/latest/bitvec/field/trait.BitField.html"><code>BitField</code></a> trait, are the two most common sources of
questions about how <code>bitvec</code> operates. Their intersection is even more complex,
and the layout of numeric integers stored into a <code>BitSlice</code> is an extremely
common point of confusion.</p>
<p>Read these chapters and the API documentation thoroughly, and experiment with
placing data into memory and changing the type parameters to observe their
effects on buffer representation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bitvec-memory-model"><a class="header" href="#bitvec-memory-model"><code>bitvec</code> Memory Model</a></h1>
<p><code>bitvec</code> addresses individual bits, while computer hardware addresses register
elements. As a result, <code>bitvec</code> has a more complex memory model than the Rust
language does. The library implementation strives to satisfy users’
expectations, the Rust language’s rules, and performance in the produced
artifact to the best solution for all parties, with as few compromises as
possible. Unfortunately, this has the side effect of increasing the complexity
of the codebase, both for maintainers and for readers.</p>
<p>This chapter explains the abstract concepts of the <code>bitvec</code> memory model and the
means by which it is encoded in the Rust language without running afoul of Rust
or LLVM rules that threaten undefined behavior.</p>
<p>The <code>bitvec</code> memory model is typed entirely within the <code>store</code> module’s
<code>BitStore</code> trait definition and implementations. It utilizes the <code>access</code>
module’s <code>BitAccess</code> trait to mediate memory access events through types that
are known to be correct in the Rust and LLVM models, so that at any point in
program execution, memory access will be consistent and sound.</p>
<p>In addition, the <code>domain</code> module’s types provide views which manipulate the
<code>store</code> model to maximize performance. This chapter will discuss primarily
<code>store</code>, and use <code>domain</code> only to provide examples of how <code>store</code> is used in
practice to accomplish the library’s implementation.</p>
<h2 id="aliasing"><a class="header" href="#aliasing">Aliasing</a></h2>
<p>To Rust and LLVM, “aliasing” occurs whenever there are two paths to a memory
region, and at least one of them has write privileges. In Rust, this is
represented by the <code>&amp;mut</code> reference exclusion rule: it is always, always,
<strong>always</strong> Undefined Behavior in the <em>Rust</em> memory model to have two
<em>references</em> which can reach a memory element if at least one of them is marked
<code>&amp;mut</code>.</p>
<p>LLVM, which was created for, is written in, and culturally shaped by C++, takes
a similar view with its <code>noalias</code> annotation, but struggles to enforce it as
thoroughly as Rust does.</p>
<p><code>bitvec</code> takes a similar view of the abstract meaning of the <code>&amp;mut</code> reference
type, but where the Rust memory model focuses on whole units <code>T</code>, and has no
concept of subdivision from <code>T</code> into the bits that compose it, <code>bitvec</code> views
each individual bit as a standalone, independent, atom of memory. It excludes
the creation of two <code>&amp;mut BitSlice</code> reference handles that are capable of
viewing the same <em>bit</em>, but will happily produce two <code>&amp;mut BitSlice</code> handles
which are mutually-exclusive in bits, but reference the same location in memory.</p>
<pre><code class="language-admonish info">Think of it like disjoint `&amp;mut u64` references whose referent words are in the
same cacheline. The software model doesn’t care; making this work is the
hardware’s problem. Similarly, users of the `bitvec` library don’t need to care
about the fact that disjoint `&amp;mut BitSlice` references might refer to the same
element.
</code></pre>
<p>Here we come to the first problem with the conflicting memory models: <code>bitvec</code>
cannot ever create an <code>&amp;mut T</code> through which it may write to memory, because it
has no way of ensuring that no other <code>&amp;T</code> or <code>&amp;mut T</code> reference exists which is
capable of viewing the memory region into which it writes.</p>
<h3 id="rust-shared-mutation"><a class="header" href="#rust-shared-mutation">Rust Shared Mutation</a></h3>
<p>The problem isn’t just that the Rust standard library doesn’t offer any
non-<code>unsafe</code> APIs to produce such references. The problem is that this is about
the most illegal thing you can do in the eyes of the Rust compiler, and if it
ever detects this transgression, it has full liberty to either reject, or worse,
accept <em>and miscompile</em>, your program.</p>
<p>In Gankra’s <a href="https://doc.rust-lang.org/stable/nomicon/transmutes.html">immortal words</a> on the topic of attempting to sneak past the
compiler’s commandments,</p>
<blockquote>
<ul>
<li>Transmuting an <code>&amp;</code> to <code>&amp;mut</code> is <em>always</em> UB</li>
<li>No you can’t do it</li>
<li>No you’re not special</li>
</ul>
</blockquote>
<p>The solution is simple: Rust exposes a type, <a href="https://doc.rust-lang.org/stable/core/cell/struct.UnsafeCell.html"><code>UnsafeCell</code></a>, which is the
axiomatic type for mutation through shared views. In the Rust memory model, any
reference to a region of memory marked with <code>UnsafeCell</code> is permitted to write
to it, and if any other references can view that region, then it is up to them
to ensure consistent behavior.</p>
<p>This is, of course, not <em>quite</em> true in LLVM’s memory model, but we are not
there yet.</p>
<p>Since an <code>&amp;mut BitSlice&lt;T, _&gt;</code> handle cannot produce an <code>&amp;mut T</code> reference to
perform writes to memory, it must instead either use a <code>*mut T</code> bare pointer,
which has absolutely no checks or optimizations whatsoëver, or use an
<code>&amp;UnsafeCell&lt;T&gt;</code> shared reference, which has all the usual guarantees present on
all<sup class="footnote-reference" id="fr-1-1"><a href="#footnote-1">1</a></sup> reference types.</p>
<p>All <code>UnsafeCell</code> does is instruct the Rust compiler to politely look the other
way about your program’s memory accesses. It is somewhat like the C keyword
<code>volatile</code>, in that the compiler no longer believes that reads are stateless, or
freely reörderable, but entirely unlike that keyword in that the compiler
doesn’t have any obligation to <em>keep</em> your reads from or writes to such regions.</p>
<p>Rust provides an additional type called <a href="https://doc.rust-lang.org/stable/core/cell/struct.Cell.html"><code>Cell</code></a>. This is a wrapper over
<code>UnsafeCell</code><sup class="footnote-reference" id="fr-2-1"><a href="#footnote-2">2</a></sup> that defines a more useful API, including the only safe and
guaranteed way to write into memory through a shared reference: <a href="https://doc.rust-lang.org/stable/core/cell/struct.Cell.html#method.set"><code>Cell::set</code></a>.</p>
<p>And <em>voilà</em>: <code>&amp;mut BitSlice&lt;T, _&gt;</code> simply constructs <code>&amp;Cell&lt;T&gt;</code> when writing,
the Rust compiler does not see a violation of the <code>&amp;mut</code> exclusion principle,
and we are done.</p>
<h3 id="llvm-shared-mutation"><a class="header" href="#llvm-shared-mutation">LLVM Shared Mutation</a></h3>
<p>No we’re not. If it was that easy, there wouldn’t be a trait system or this
document dedicated specifically to dealing with this problem.</p>
<p><code>Cell</code> is not thread-safe, because <code>Cell</code> does not modify the instructions used
to access memory. It produces ordinary load and store instructions, carefree and
ignorant of the bane of everyone who wants consistency and the delight of
everyone who wants performance: concurrency.</p>
<p>Just as it is undefined behavior in Rust to manifest two <code>&amp;mut</code> references that
can view the same location, it is equally undefined behavior in LLVM to manifest
two pointers into memory that ever, at all, no matter <strong>what</strong>, perform any
memory access to the same location, at the same time, on multiple threads of
execution.</p>
<p>As with above:</p>
<blockquote>
<ul>
<li>Unsynchronized writes are <em>always</em> UB.</li>
<li>No you can’t do it.</li>
<li>No you’re not special.</li>
</ul>
</blockquote>
<p>LLVM has an even more insidious punishment for this transgression that Rust does
not directly express: unsynchronized reads from a data race produce <a href="https://llvm.org/docs/LangRef.html#poison-values"><code>poison</code></a>.
Poison is a nifty concept, because it’s not illegal to obtain one. When LLVM
gives you a <code>poison</code>, your program continues undergoing compilation as if
nothing had happened. You can pass it around. You can write to it, and if you
destroy it before reading, you’re fine.</p>
<p>As soon as you attempt to read the bit-wise value of <code>poison</code>, your program is
undefined<sup class="footnote-reference" id="fr-3-1"><a href="#footnote-3">3</a></sup>.</p>
<p>So if <code>bitvec</code> wants to be threadsafe, which it does, and it wants to insist on
its ability to safely alias the same memory location from multiple handles,
which is non-negotiable, there’s only one avenue left to take.</p>
<h3 id="atomic-powered-microscopes"><a class="header" href="#atomic-powered-microscopes">Atomic Powered Microscopes</a></h3>
<p>Rust doesn’t actually model atomics. It doesn’t have to do so: no harm can ever
come from multiple handles reading out of the same immutable location, harm can
only occur when writes are observable, and writes are not observable due to the
<code>&amp;mut</code> exclusion rule. Well, except for <code>UnsafeCell</code>, so everything that has an
<code>UnsafeCell</code> in it gets marked as <code>!Send</code>, <code>&amp;</code> references can’t cross threads,
and the whole problem is avoided.</p>
<p>This is, of course, not good enough. Concurrent, mutable, access to a location
is an important property in a computer. LLVM provides atomic types, which Rust
transparently exports as wrappers over <code>UnsafeCell</code> that have their <code>Sync</code>
implementation restored. Handles to a region marked as atomic will use some form
of hardware-provided exclusion in order to preserve the
one-writer-XOR-any-readers system behavior, and all is well.</p>
<p>Hardware-level exclusion has the unfortunate penalty of being, to put it
lightly, “slow”. So while it’s the safest choice to be correct, and was in fact
the default universal choice for all memory access in <code>bitvec</code> for some time,
its costs<sup class="footnote-reference" id="fr-4-1"><a href="#footnote-4">4</a></sup> called for a more prudent behavior.</p>
<p>It’s time for a new trick, something that the Rust compiler does at the region
level, and that <code>bitvec</code> now does at the element level:</p>
<h2 id="run-time-alias-analysis"><a class="header" href="#run-time-alias-analysis">Run Time Alias Analysis</a></h2>
<p><code>BitSlice</code> handles can only be constructed from ordinary Rust references to
memory, which Rust guarantees start out unaliased. The potential for aliasing
only occurs when a <code>&amp;mut BitSlice</code> is split into multiple subslices using any
of the functions that eventually call <code>.split_at_unchecked_mut()</code>. Since that is
the root function that introduces alias conditions, it returns subslices whose
memory type parameters are tainted with the <code>::Alias</code> marker. It has the
following type signature:</p>
<pre><code class="language-rust">impl&lt;T, O&gt; BitSlice&lt;T, O&gt;
where O: BitOrder, T: BitStore {
  pub fn split_at_unchecked_mut(&amp;mut self, at: usize) -&gt; (
    &amp;mut BitSlice&lt;T::Alias, O&gt;,
    &amp;mut BitSlice&lt;T::Alias, O&gt;,
  );
}</code></pre>
<p>The <code>BitStore</code> trait defines an <code>::Alias</code> associated type, which ensures that
all memory accesses through it have appropriate aliasing guards. For builds
which do not use the <code>atomic</code> feature (or where the target does not have an
atomic variant of the integer), this is <code>Cell</code>, and its protections are the loss
of thread-safety. For builds that do permit atomics, the marker enforces that
all reads and writes use atomic instructions.</p>
<p>The <code>::Alias</code> marker is applied, at compile time, by operations that split
<code>&amp;mut BitSlice</code> references into multiple coëxisting subslices. This is a good
first step to reducing unnecessary synchrony, but not good enough. Consider the
following:</p>
<pre><code class="language-rust">use bitvec::prelude::*;

let mut data = [0u8; 2];
let bits = data.view_bits_mut::&lt;Lsb0&gt;();
let (one, two) = data.split_at_mut(8);</code></pre>
<p>It so happens that this is equivalent to splitting <code>data</code> first, then viewing
each subslice as bits, but this transformation can only be done if the partition
point is known at compile-time to fall on an element boundary. There is no need
for the subslices <code>one</code> and <code>two</code> to use alias-safe operations, as accesses to
memory through them do not conflict with each other.</p>
<h3 id="bit-slice-domains"><a class="header" href="#bit-slice-domains">Bit Slice Domains</a></h3>
<p>The in-memory domain of any bit slice can be generalized to one of two formats:
either the slice touches zero edge-bits (<code>0</code> or <code>T::BITS - 1</code>), or it touches at
least one edge-bit in at least one element. Consider three bytes of memory (any
element will do, but the extra width on this page is unnecessary), with some
bitslice regions drawn within them:</p>
<pre><code class="language-text">|00000000│11111111│22222222| Element
|76543210│76543210│76543210│ Bit
├────────┼────────┼────────┤
│        ┆        ┆        │ 1
│        ┆xxxxx   ┆        │ 2
│        ┆ xxxxx  ┆        │ 3
│        ┆   xxxxx┆        │ 4
│  xxxxxx┆xxxx    ┆        │ 5
│    xxxx┆xxxxxxxx┆        │ 6
│        ┆xxxxxxxx┆xxxx    │ 7
│      xx┆xxxxxxxx┆xx      │ 8
│xxxxxxxx┆xxxxxxxx┆xxxxxxxx│ 9
</code></pre>
<p>There are nine example slices here, but they can be reduced into six specific
categories, and two general ones:</p>
<ol>
<li>empty: row 1</li>
<li>minor (interior of an element, no edge indices): row 3</li>
<li>partially-spanning head, fully-spanning body: rows 3 and 6</li>
<li>partially-spanning tail, fully-spanning body: rows 2 and 7</li>
<li>major (partial head, partial tail, full body): rows 5 and 8</li>
<li>spanning: row 9</li>
</ol>
<p>The minor slice (row 3) is irreducible; the rest can all be divided into three
subcomponents:</p>
<ul>
<li>zero or one partially-occupied head element, where the slice touches the last
index in it but not the first</li>
<li>zero or more fully-occupied middle elements, where the slice touches all
indices in each</li>
<li>zero or one partially-occupied tail element, where the slice touches the first
index in it but not the last</li>
</ul>
<p>We can break each row down into these components:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Row</th><th style="text-align: center">Head</th><th style="text-align: center">Body</th><th style="text-align: center">Tail</th></tr></thead><tbody>
<tr><td style="text-align: center">1</td><td style="text-align: center">None</td><td style="text-align: center">0</td><td style="text-align: center">None</td></tr>
<tr><td style="text-align: center">2</td><td style="text-align: center">None</td><td style="text-align: center">0</td><td style="text-align: center">Some</td></tr>
<tr><td style="text-align: center">4</td><td style="text-align: center">Some</td><td style="text-align: center">0</td><td style="text-align: center">None</td></tr>
<tr><td style="text-align: center">5</td><td style="text-align: center">Some</td><td style="text-align: center">0</td><td style="text-align: center">Some</td></tr>
<tr><td style="text-align: center">6</td><td style="text-align: center">Some</td><td style="text-align: center">1</td><td style="text-align: center">None</td></tr>
<tr><td style="text-align: center">7</td><td style="text-align: center">None</td><td style="text-align: center">1</td><td style="text-align: center">Some</td></tr>
<tr><td style="text-align: center">8</td><td style="text-align: center">Some</td><td style="text-align: center">1</td><td style="text-align: center">Some</td></tr>
<tr><td style="text-align: center">9</td><td style="text-align: center">None</td><td style="text-align: center">3</td><td style="text-align: center">None</td></tr>
</tbody></table>
</div>
<p>We can observe that where a slice fully-spans some elements, those elements
cannot be mutated by any other reference. In the <code>&amp;BitSlice</code> case, all <code>&amp;mut</code>s
are forbidden by the compiler’s ordinary rules; in the <code>&amp;mut BitSlice</code> case,
<code>bitvec</code>’s obedience to those same rules forbids any other handle from observing
the bits covered by the <code>&amp;mut BitSlice</code>. As such, it is statically impossible
for any alias to exist to the described memory in row 9, or for any alias to
observe element <code>1</code> of rows 6 through 8.</p>
<p><code>bitvec</code> happily permits element-aliasing <code>&amp;mut BitSlice</code> references to observe
the partially-filled elements in the outer columns, and middle column of rows 2
through 5, so writes to them must remain synchronized through either
single-threaded <code>Cell</code> or concurrency-safe atomics. These domain components can
be calculated from the three components of a slice pointer: the base address,
the starting bit index, and the bit count.</p>
<p>This is expressed in the <code>domain</code> module’s two enums.</p>
<h3 id="bitdomain"><a class="header" href="#bitdomain"><code>BitDomain</code></a></h3>
<p>This enum splits any <code>BitSlice</code> region into its subcomponents, immutably or
mutably, respectively. It has the (rough) definition</p>
<pre><code class="language-rust">pub enum BitDomain&lt;'a, M, T, O&gt;
where
  M: Mutability,
  T: BitStore,
  O: BitOrder,
{
  Enclave(Reference&lt;'a, M, BitSlice&lt;T, O&gt;&gt;),
  Region {
    head: Reference&lt;'a, M, BitSlice&lt;T, O&gt;&gt;,
    body: Reference&lt;'a, M, BitSlice&lt;T::Unalias, O&gt;&gt;,
    tail: Reference&lt;'a, M, BitSlice&lt;T, O&gt;&gt;,
  },
}</code></pre>
<p>and, rather than granting direct memory access, merely removes any aliasing
markers from as much memory as possible. The subslices that partially fill their
base element do not need to add an additional aliasing marker, as the marker is
only required when writes to the element may collide. If the slice is immutable,
aliasing never occurs, so synchrony is never required. If the slice is mutable,
then the only way to get a partial edge slice is to either forget about some
bits from the main slice, which is <em>not</em> an alias event, or to split the slice,
which <em>is</em>, and splitting already marks the alias.</p>
<h3 id="domain"><a class="header" href="#domain"><code>Domain</code></a></h3>
<p>The bit domains are still bit slices, and do not offer a way to access the
backing memory. For operations where raw memory access is required, this enum
produces the same domain definitions, but typed for the bare elements rather
than their bits.</p>
<p>It has the (rough) definition</p>
<pre><code class="language-rust">pub enum Domain&lt;'a, M, T&gt;
where
  M: Mutability,
  T: BitStore,
{
  Enclave(PartialElement&lt;T&gt;),
  Region {
    head: Option&lt;PartialElement&lt;T&gt;&gt;,
    body: Reference&lt;'a, M, [T::Unalias]&gt;,
    tail: Option&lt;PartialElement&lt;T&gt;&gt;,
  },
}</code></pre>
<p>(The <code>PartialElement</code> type is a guarded reference which prevents accessing bits
that do not belong to the originating <code>BitSlice</code>.)</p>
<p>As with the bit domains, these domains will inherit any aliasing markers from
their source bitslice. The <code>::Alias</code> associated type enables the mutable domain
to produce references that allow mutation without adding an unnecessary
aliasing marker. Rust strongly forbids the production of <code>&amp;mut</code> references to
aliased memory elements, which is why the only <code>&amp;mut</code> reference in these views
is to memory that is fully known to be unaliased.</p>
<p>The <code>Domain</code> structure will produce bare <a href="https://doc.rust-lang.org/stable/core/sync/atomic">atomic</a> or <a href="https://doc.rust-lang.org/stable/core/cell/struct.Cell.html"><code>Cell</code></a> types in the
alias condition. This is necessary in order to avoid production of <code>&amp;mut</code>
references which alias (as this is undefined in the Rust abstract machine,
regardless of behavior), and safe because any other references to the same
location will be similarly aliased and capable of handling external mutation.</p>
<h2 id="llvm-suboptimizations"><a class="header" href="#llvm-suboptimizations">LLVM Suboptimizations</a></h2>
<p>LLVM considers a “racing read”, that is, any read from memory that could occur
contemporaneously with an atomic write, to be undefined behavior. This is a
reasonable view to take, but a pessimistic one. <code>bitvec</code> has information that
cannot be expressed to LLVM about which <strong>bits</strong> of an element it will observe
or modify, and <code>bitvec</code> is capable of guaranteeing that two distinct access
points will not be able to interfere with each other electrically. LLVM does not
know this, so it considers any write to memory to touch <em>all</em> bits of the
touched element, and any read from memory to view <em>all</em> bits of the fetched
element.</p>
<p><code>bitvec</code> exclusively<sup class="footnote-reference" id="fr-5-1"><a href="#footnote-5">5</a></sup> writes to contended memory with the Rust functions
<a href="https://doc.rust-lang.org/stable/core/sync/atomic/struct.AtomicUsize.html#method.fetch_and"><code>AtomicT::fetch_and</code></a> and <a href="https://doc.rust-lang.org/stable/core/sync/atomic/struct.AtomicUsize.html#method.fetch_or"><code>AtomicT::fetch_or</code></a>, which are mapped to the LLVM
instructions <a href="https://releases.llvm.org/10.0.0/docs/Atomics.html#libcalls-atomic"><code>__atomic_fetch_and_N</code></a> and
<a href="https://releases.llvm.org/10.0.0/docs/Atomics.html#libcalls-atomic"><code>__atomic_fetch_or_N</code></a>. It uses bitmasks that <em><code>bitvec</code></em> can
<a href="https://github.com/myrrlyn/bitvec/blob/HEAD/src/order.rs">guarantee</a> are non-intersecting, but this proof cannot be extended to
even the Rust compiler, let alone LLVM. These bitmasks are applied to register
values before using either of the <code>fetch_op</code> instructions, and after any reads
that use <a href="https://doc.rust-lang.org/stable/core/sync/atomic/struct.AtomicUsize.html#method.load"><code>AtomicT::load</code></a>/<a href="https://releases.llvm.org/10.0.0/docs/Atomics.html#libcalls-atomic"><code>__atomic_load_N</code></a>.</p>
<p>If the <code>bitvec</code> mask proofs were extendible to LLVM, and LLVM were to expand its
tracking of which bits of a memory address became <code>poison</code>ed by a memory write,
and which bits of a fetched memory value became un-<code>poison</code>ed by a masking
operation, then the compiler would be more able to observe that <code>bitvec</code> memory
accesses do not <em>observably</em> interfere with each other. This observation would
then define the behavior in the compiler’s memory model of racing writes/reads,
and permit an increased (possibly even complete) removal of synchrony guards.</p>
<pre><code class="language-admonish info">I am not aware of any processor hardware which fails to guarantee that all bits
of memory are fully defined at the clock edges of all instructions that use the
location. To the full extent my knowledge, all memory banks in all relevant
processors have a stable bit-value at the start of a tick, when reads occur, and
at the end of a tick, when writes commit. At no point does changing the value of
one bit of a memory component affect the electrical value of other bits in the
component.

This is not necessarily true of other storage devices, such as SSDs, but
`bitvec` can only be used to access storage cells mapped in the RAM address
space, which tend to all have this stability property.
</code></pre>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>The formal definition of the <code>bitvec</code> memory model extends the Rust
mutable-exclusion rules by refining memory regions to have bit-precision instead
of element-precision. The Rust compiler is only weakly capable of tracking the
region status of individual bits, and only in compiler-internal structures. LLVM
has a more robust arbitrary-bit-tracking capability, but similarly limits its
interface to external code.</p>
<p>Barring any errors in the <code>bitvec</code> implementation, the <code>bitvec</code> memory model is
fully sound in its behavior with regard to single-observer unsynchrony.
Synchronization is only added in order to correctly interface with <code>rustc</code> and
LLVM without causing either of them to introduce undefined behavior due to a
lack of information.</p>
<h2 id="footnotes-1"><a class="header" href="#footnotes-1">Footnotes</a></h2>
<hr>
<ol class="footnote-definition"><li id="footnote-1">
<p>all references to <code>T</code> where <code>T</code> is either <code>!Sized</code>, or
<code>mem::size_of::&lt;T&gt;()</code> is non-zero, that is. A fun quirk of Rust’s first-class
concept of zero-width types is that the only illegal value for a <code>&amp;Zst</code>
reference is null. Since there is nothing to load or store through a <code>&amp;Zst</code>
reference, the compiler doesn’t <em>care</em> what the reference value is, as it will
never be used to perform memory access. <a href="#fr-1-1">↩</a></p>
</li>
<li id="footnote-2">
<p>literally: <a href="https://doc.rust-lang.org/1.43.0/src/core/cell.rs.html#232-235">https://doc.rust-lang.org/1.43.0/src/core/cell.rs.html#232-235</a> <a href="#fr-2-1">↩</a></p>
</li>
<li id="footnote-3">
<p>This is not <em>absolutely</em> true. Like we saw with <code>UnsafeCell</code>, the only
immutable rule of compiler developers is that whenever they make an immutable
rule, they also provide a way to sidestep it. If you <a href="https://llvm.org/docs/LangRef.html#i-freeze"><code>freeze</code></a> a <code>poison</code>,
you are now free to read its value and act on it. LLVM just doesn’t make any
guarantees about what bit-pattern you’ll see. <a href="#fr-3-1">↩</a></p>
</li>
<li id="footnote-4">
<p>I’d feel a great deal more comfortable if I had firm knowledge of what
those costs actually <strong>were</strong>. An atomic write always issues a <code>lock</code>
instruction modifier on x86, and I have heard vastly different things about
what that actually <em>means</em>, from “it’s free if no other cache holds that
address” up to “it poisons the whole cacheline”, and have not had much luck
producing a benchmark that firmly demonstrates that unneeded atomic access is
a strict performance cost. <a href="#fr-4-1">↩</a></p>
</li>
<li id="footnote-5">
<p>In multithreading environments. Disabling atomics also disables <code>bitvec</code>’s
support for multithreading, so the penalty for aliasing is reduced to an
inability to remove redundant reads. <a href="#fr-5-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="runtime-performance"><a class="header" href="#runtime-performance">Runtime Performance</a></h1>
<p><code>bitvec</code> increases the instruction cost of each access to a <code>bool</code> in its data
structures. This is an inevitable consequence of the fact that, even on
architectures that have them, compilers typically do not emit object code
instructions that access individual bits within a memory location. Therefore,
each access in <code>bitvec</code> has, in addition to a memory operation, one or two
shift instructions one or two <code>AND</code>/<code>OR</code>/<code>NOT</code> instructions.</p>
<p>This means that, inevitably, <code>bitvec</code> is slower in CPU time than <code>[bool]</code> is.
Measurements indicate roughly a factor of ten, but with also about 10x more
variance. However, this cost is only apparent <em>and meaningful</em> when walking the
entirety of very large buffers, and tends to fade into noise on smaller buffers,
or be obviated by compile-time fixed accesses. As always, try it on a
representative workload.</p>
<h2 id="benchmarking"><a class="header" href="#benchmarking">Benchmarking</a></h2>
<p>I have tried (with admittedly low priority) to have some benchmarks in the
project to back up my claims that <code>bitvec</code> is fast. This has been difficult to
maintain for a few reasons, but I have at least a few that have stayed present
in order to demonstrate important claims, such as showing that specialization
for matching types does provide massive performance benefits (it does).</p>
<p>In particular, LLVM is <em>very good</em> at propagating compile-time constants through
the code, and <code>bitvec</code> strives to maintain an internal implementation that is
easily accessible to optimizers. This means that basically any benchmark that
takes input from a source file that the compiler can see gets artificially
solved during codegen.</p>
<p>For instance, I don’t know how long it takes to construct a <code>&amp;BitSlice</code> view
over memory, because my benchmarks report 0ns: LLVM computes my pointer encoding
at compile time, and a consequence of the way I designed my pointer encoding is
that the only operation <code>BitSlice::from_slice</code> actually performs is <code>.len &lt;&lt; 3</code>.
When LLVM can see the original length, it just does this itself, and emits an
immediate with the correct length instead of the constructor call.</p>
<p>Other constructor benchmarks are only showing me the time required to run
<code>memcpy</code>, and arbitrary indexing just shows the time required to run three
instructions, because LLVM solved the shift/mask arguments ahead of time.</p>
<p>The important takeäway here is that if your code is at all dependent on
constants that the compiler can see, and is not exclusively performing indexing
based on runtime inputs, then <code>bitvec</code> is going to be <em>plenty</em> fast.</p>
<h2 id="pitfalls"><a class="header" href="#pitfalls">Pitfalls</a></h2>
<p>Everything stated above relies on having information available to the compiler.
<code>bitvec</code> falls behind other bit-reading libraries when you start using access
patterns only known at runtime, such as iteration.</p>
<p>Until Rust stabilizes the <code>ptr_metadata</code> feature (see <a href="https://github.com/rust-lang/rust/issues/81513">#81513</a>), <code>bitvec</code> will
necessarily take a performance hit because it has to decode the <code>&amp;BitSlice</code>
pointer every time you access memory, and reëncode it every time you munch
through the region.</p>
<p>The <code>bitvec</code> pointer encoding (described <a href="bitvec/./pointer-encoding.html">here</a>) requires manipulating
both words in the pointer with at least three instructions each.</p>
<pre><code class="language-admonish info">Except when using `u8` storage, which discards *most* of the modifications to
the address half of the pointer. Try that out if you do a lot more munching
through a region than bulk work on its contents!
</code></pre>
<p>This would not be necessary if the pointer could use its own metadata type
rather than <code>usize</code>. Until that stabilizes, the entire value proposition of the
crate rests on the fact that <code>&amp;BitSlice</code> has slice-pointer ABI. If you
absolutely cannot afford to have decoding/reëncoding costs in your hot loop, you
may have to try other libraries.</p>
<p><code>bitvec</code> strives to use batch operations on entire integer registers when
possible. However, doing so requires routing through the <code>domain</code> module, which
has to perform similar decoding and processing of a <code>&amp;BitSlice</code> pointer every
time it is entered. This is another unavoidable cost. It is <em>generally</em> a
tolerable overhead compared to walking through each bit individually, especially
with wider storage integers, but it is one more thing that other bit-addressing
libraries don’t do.</p>
<p>Other libraries also do not have alias safety or tolerance for starting a region
away from the zero-index in an integer. Power has a price. We do our best to cut
down the library’s runtime cost as much as possible, but this computation simply
has to be done somewhere, and it's not built in to silicon anymore. Sorry.</p>
<h2 id="specialization"><a class="header" href="#specialization">Specialization</a></h2>
<p><code>bitvec</code> strives to use its knowledge of the underlying memory representation
wherever possible. This means that operations between <code>BitSlice</code>s with the same
type parameters can rely on an identical representation and use integer behavior
rather than walking each bit individually.</p>
<p>Try to do this wherever possible, especially in performance-sensitive code. You
typically should not be mixing <code>bitvec</code> structures with different type
parameters anyway: use the representation that serves your needs, and keep using
it in all buffers that interact with it.</p>
<p>As an example, as of 1.0, walking two large <code>BitSlice</code>s with incompatible type
parameters takes 3µs (microseconds), while walking the same sizes with
identical type parameters takes 100ns (nanoseconds). It’s roughly a 32x
performance difference, which is only half the speedup that I expected using
<code>usize</code> on a 64-bit machine, but still quite stark.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bit-slice-pointer-encoding"><a class="header" href="#bit-slice-pointer-encoding">Bit Slice Pointer Encoding</a></h1>
<p><code>bitvec</code>’s core value proposition rests on the fact that it is capable of
defining an unsized slice type, and controlling references to it. The Rust
language rests heavily on the two reference types <code>&amp;</code> and <code>&amp;mut</code>, and does not
ordinarily allow these to be faked or created by anything other than the
compiler.</p>
<h2 id="rust-reference-rules"><a class="header" href="#rust-reference-rules">Rust Reference Rules</a></h2>
<p>It so happens that not only does Rust strongly guarantee the <a href="https://github.com/rust-lang/rust/blob/8558ccd/src/libcore/ptr/mod.rs#L220-L231">in-memory layout</a>
of a reference to a slice, it also provides a stable API for
<a href="https://github.com/rust-lang/rust/blob/8558ccd/src/libcore/slice/mod.rs#L5642-L5739">constructing values</a> of <code>&amp;[T]</code> type without using <code>mem::transmute</code>. Subject to
certain value requirements imposed by types, slice references can be constructed
through these functions and the compiler will accept them as valid.</p>
<p>These requirements traditionally make it difficult to encode non-address
information into a bare reference, since the compiler has a very firm
expectation that a reference to a type is immediately dereferenceäble to a value
of that type, but if your type happens to be zero-sized, then it can never exist
in memory, no loads or stores to it can ever be produced, and the compiler no
longer concerns itself with the actual bit-pattern value of references to it.</p>
<p>Which is why the definition of <code>BitSlice</code> is</p>
<pre><code class="language-rust">//  src/slice.rs

#[repr(transparent)]
pub struct BitSlice&lt;T, O&gt;
where
  T: BitStore,
  O: BitOrder,
{
  _mem: [()],
  _typ: PhantomData&lt;T&gt;,
  _ord: PhantomData&lt;O&gt;,
}</code></pre>
<p><code>BitSlice</code> is <code>[()]</code> (a slice of the unit value) with some markers that only the
type-checker can see. <code>&amp;BitSlice</code> is thus <code>&amp;[()]</code>, and <code>&amp;[()]</code> can have any
values it wants (except, of course, null) – the unit value has no alignment
requirements, can be placed anywhere in memory without worrying about whether
there is a backing allocation, and can have as many instances of itself as
desired.</p>
<p>Zero-sized types are an <em>absurdly</em> powerful concept when working with memory
that the language expects to be able to manifest at any time.</p>
<h2 id="pointer-encoding"><a class="header" href="#pointer-encoding">Pointer Encoding</a></h2>
<p>Slice references contain two pieces of information: the address of the base
element, and the number of elements, starting at the base, contained in the
slice region. Theoretically, bit-slice references have the same pair of
information: the address of the first bit, and the number of bits in the region.</p>
<p>However, computers are byte-addressed, not bit-addressed, so we need to store
three more bits (to select a bit in the base byte) somewhere in the reference.
Since slice references are defined as <code>{ base: *T, elts: usize }</code>, and there are
no<sup class="footnote-reference" id="fr-1-1"><a href="#footnote-1">1</a></sup> spare bits in <code>*const _</code>, the bits to store the base bit are taken out of
the length counter.</p>
<p>Reference address values are also required to be integer multiples of the
alignment of the referent type <code>T</code>. This alignment is, on all supported targets,
the width in bytes of the referent type. As a result, there are as many low bits
in the address of any <code>T</code> that are <em>guaranteed</em> to be the <code>0</code> value, as there
are bits needed to select a byte within the element. The end result is that the
length counter must always use three bits to store the starting bit, and the
base address will be composed of an aligned <code>T</code> address and an index of the
starting byte within it.</p>
<p>As Rust does not have bitfield syntax, a definition of the pointer structure in
C++ looks like something like this<sup class="footnote-reference" id="fr-2-1"><a href="#footnote-2">2</a></sup>:</p>
<pre><code class="language-cpp">template &lt;typename T&gt;
struct BitSpan {
  static_assert(
    std::is_unsigned&lt;T&gt;()
    &amp;&amp; sizeof(T) &lt;= sizeof(std::size_t)
    &amp;&amp; sizeof(T) &lt;= alignof(T)
  );

  // on little-endian systems, bitfields are
  // allocated from LSbit and move towards MSbit
  uintptr_t ptr_head : __builtin_ctzll(alignof(T));
  uintptr_t ptr_addr : (sizeof(uintptr_t) * 8)
                     - __builtin_ctzll(alignof(T));

  size_t len_head : 3;
  size_t len_bits : (sizeof(size_t) * 8) - 3;
};
</code></pre>
<p>In Rust, the structure is declared as</p>
<pre><code class="language-rust">// src/pointer.rs

#[repr(C)]
pub struct BitSpan&lt;T, O&gt;
where
  T: BitStore,
  O: BitOrder,
{
  ptr: NonNull&lt;u8&gt;,
  len: usize,
  _ty: PhantomData&lt;T&gt;,
  _or: PhantomData&lt;O&gt;,
}</code></pre>
<p>and the logical components must be accessed through get/set functions, rather
than through compiler-generated field stubs.</p>
<p>By marking the pointer as <code>NonNull</code>, <code>BitSpan</code> declares that it will never be a
null pointer and becomes subject to the same peephole optimization that allows
<code>mem::size_of::&lt;Option&lt;&amp;T&gt;&gt;() == mem::size_of::&lt;&amp;T&gt;()</code>. By marking it as
unconditionally a pointer to <code>u8</code>, we declare that all low bits of the address
value are in use, and none can be used as slots for anything else (since our
encoding is using them to select a byte within the <code>T</code>).</p>
<h2 id="significant-values"><a class="header" href="#significant-values">Significant Values</a></h2>
<p><code>BitSpan&lt;T, O&gt;</code> does not have any sentinel values of its own, but inherits from
<code>NonNull&lt;T&gt;</code>. The completely zero value is not a valid member of the <code>BitSpan</code>
type, but rather indicates <code>Option::&lt;BitSpan&lt;_, _&gt;&gt;::None</code>, and it uses the
dangling <code>NonNull</code> pointer value to indicate an instantiated pointer object
without an associated allocation.</p>
<p>Not all zero-length regions are dead: a cleared <code>BitVec</code> region has zero length
but owns an allocation, so it cannot discard its address information.</p>
<h2 id="summary-1"><a class="header" href="#summary-1">Summary</a></h2>
<p>Rust requires that slice references have a specific ABI, but makes no
requirements about the encoding of values of those references for certain types.
We can supply our own ABI-equivalent structure, define functions that use the
structural encoding to compute the information needed to actually interact with
memory, and convert our structures into Rust-accepted slices through the
provided compiler API in <code>core</code>.</p>
<p>If and when the <code>ptr_metadata</code> feature stabilizes, <code>bitvec</code> will experiment with
discarding this packed encoding in favor of a three-word pointer. If the
unpacked pointer results in better performance by eliminating the need for the
special encoding, <code>bitvec</code> will release a new <strong>minor</strong> version with the changed
structure.</p>
<pre><code class="language-admonish info">`bitvec`’s MSRV policy is that raising compiler requirements is a minor change,
not major, and the pointer ABI is **not public interface**! You are already
forbidden from moving bit-region pointers out of a program, so this change will
not affect your program’s behavior.
</code></pre>
<h2 id="footnotes-2"><a class="header" href="#footnotes-2">Footnotes</a></h2>
<pre><code class="language-cpp">// compiles on x86-64 clang 15.0.0
#include &lt;climits&gt;
#include &lt;cstddef&gt;
#include &lt;cstdint&gt;
#include &lt;type_traits&gt;

static_assert(CHAR_BIT == 8, "this target is not supported");

template &lt;typename T&gt;
struct BitSpan {
  static_assert(
    std::is_unsigned&lt;T&gt;()
    &amp;&amp; sizeof(T) &lt;= sizeof(std::size_t)
    &amp;&amp; sizeof(T) &lt;= alignof(T),
    "this type is not supported as BitSpan storage"
  );

  uintptr_t ptr_head : __builtin_ctzll(alignof(T));
  uintptr_t ptr_addr : (sizeof(uintptr_t) * 8)
                    - __builtin_ctzll(alignof(T));

  size_t len_head : 3;
  size_t len_bits : (sizeof(size_t) * 8) - 3;
};

template &lt;&gt;
struct BitSpan&lt;uint8_t&gt; {
  // ptr_head is zero bits wide when targeting bytes
  uintptr_t ptr_addr;
  size_t len_head : 3;
  size_t len_bits : (sizeof(size_t) * 8) - 3;
};

static uint64_t data[4];

BitSpan&lt;uint8_t&gt; one() {
  return {
    .ptr_addr = (uintptr_t)&amp;data[0],
    .len_head = 1,
    .len_bits = 6,
  };
}

BitSpan&lt;uint16_t&gt; two() {
  return {
    .ptr_head = 1,
    .ptr_addr = (uintptr_t)&amp;data[1],
    .len_head = 1,
    .len_bits = 5,
  };
}
BitSpan&lt;uint32_t&gt; four() {
  return {
    .ptr_head = 2,
    .ptr_addr = (uintptr_t)&amp;data[2],
    .len_head = 3,
    .len_bits = 10,
  };
}
BitSpan&lt;uint64_t&gt; eight() {
  return {
    .ptr_head = 4,
    .ptr_addr = (uintptr_t)&amp;data[3],
    .len_head = 5,
    .len_bits = 25,
  };
}
</code></pre>
<hr>
<ol class="footnote-definition"><li id="footnote-1">
<p>On AMD64, pointers are actually aggregates of <a href="https://en.wikipedia.org/wiki/X86-64#Virtual_address_space_details">MMU translation pages</a>, and
processors only decode the low 48 or 57 bits of them, leaving the high 16 or 7
bits available for other information not part of the memory addressing system.
However, these processors also trap when attempting to dereference a pointer
whose high <code>[48:64]</code> or <code>[57:64]</code> bits do not have the same bit value as bit
<code>[47]</code> or <code>[56]</code>, and that bit is typically used to differentiate unprivileged
user memory from privileged kernel memory. Furthermore, this dead region does
not exist on 32-bit architectures, x86 or otherwise, and since <code>bitvec</code>
explicitly supports 32-bit systems, the use of dead bits only present on a
subset of supported targets and subject to their own extra rules is not
worthwhile. <a href="#fr-1-1">↩</a></p>
</li>
<li id="footnote-2">
<p>Here is a full code listing which you can also <a href="https://clang.godbolt.org/#z:OYLghAFBqd5QCxAYwPYBMCmBRdBLAF1QCcAaPECAMzwBtMA7AQwFtMQByARg9KtQYEAysib0QXACx8BBAKoBnTAAUAHpwAMvAFYTStJg1DIApACYAQuYukl9ZATwDKjdAGFUtAK4sGe1wAyeAyYAHI%2BAEaYxCAAbADspAAOqAqETgwe3r56KWmOAkEh4SxRMQm2mPYFDEIETMQEWT5%2BXJXVGXUNBEVhkdF6CvWNzTltQ929JWUSAJS2qF7EyOwc5gDMwcjeWADUJutu23gshAoH2CYaAIIbWzuY%2B4fIQ%2BhYVBdXt2abDNteewOR1ewQInxudz%2BDyebgIAE8kpgAPoEYhMM7g243CaOZBIpgKJSNCBuAAS1wASkiLABJAAqTwAIgdGbsABykfZmMwEBB4BS7YbATAEXb83YMVCihReJIpRqYdDmMyzA5WCE3AiYFhJAxamHwxHMNi7OmYobELwOXYWQhCJKGfbxdXXXa7HF4PEEokECBfN1u14gED8pFeBhpYAhJWHM3rbAQVU3ANc2LmWLuvAAL0wqCoEDpsxhLMzObzECDIDSOZRSddAfT6dLufzheL61ZYjwUfLhdI/ob3N54sNj3FkulsvlWvQuwJNrtDoY7qIaOFyoHqvWLoHXlBSVRKN2B%2BISIQmCYs5AuyRSIie9ojgYSIcWdotAgXZ7rdmW5dbr3QQTyPYDL3QYhdmvCtsxbCBAIIYCCCLAAqdk6xTDDMMwgBaG87wfJ8XwIN8Py/SUfz/L4B2rZFRXoZ9z0vSDdnWNVqJgo96LvM5mOgst8xo2tdlQtki1w1jtyo%2BJmUkjVri1HU9UeIFzVRK1RVtYQlyBeC2RRC4nX/XYAHpjOPQ9GNncUc2IVBdgiHiAHc8D2Rzz2XIURWCYB7LhLVzmTXZ4MQ8zTzA4g2MCwS6MYM8LyvFjIvraLdi4hyCAFKCaPLaKULQ3ZxKSkxpKK7F6lxILQViSQj3QJh6hMABWCxJCamSdxuTT7UMHTQT0sF412ARMETQyB2IEUlmXYqjLdAA6UC3ggks4P3Q8kPTOqGuajQ2v7QL5q4yymV2NoB0O2L0oFEtYn2%2BtivaqTmTkrrtMOeCuFifTBoIRzUFGmbxsm4hpudc7dgWiz4pOs6DohxbwJO1agPW1UzFiLamCaiwuD28G5qO6GS1h%2BsLufK6Tsau63QeoqSs6xceve0F1jMb7sF2fglgBsHAomggprGuHIdPY6SzMamAxF/ElqR4LUc2%2Bqseasw8eFwmmJLdZJbJ7iMphjRJdp2Tbnp65XqZtx4Oq9ndkwbsEF9ItAb54HQdm%2BGoc1jtdmkfGEeWn3kYQhX0cx7HWMaxkdYhjXZxLKn8bSnjxcTwLjZ3M2OHmWhOEa3g/A4LRSFQTg3Gsax3UWZZlJ%2BHhSAITRs/mABrEBGsN3OOEkAum5LzheAUEBDcbovs9IOBYBgRAUFQHU6GichKDQef6BibZDGALgO8NrAADdPUwAA1PBMEcgB5I1OHrmhH2iIeIAiPuHOYYg4Wv3gX4aOFz4ibRMAcB/UgK82CCHPgwWg78x6kCwCwTe4hoH4Amg4PAe9MBD2gZgVQACvBaiAaCKofdaB4AiGiN%2BHgsB91RCcD%2B8wqAGGAAoE%2BZ9L6MCAfwQQIgxDsCkDIQQigVDqGgboNoBgjAoArpYfQJCh6QHmKgA8GQMGDyqAAmoLgGDuE8C0fwmipj9BiG0PI6QBCjFaMkVIJiGD6NKAMcYqiUECC6CMbRYx2hqM6MMHowQ%2Bi2MMbYLxZjBheJsTMLg8wFDVxWHMfQede7QNLhwXYqg2SxGwtVXYG8jCnUanNDQeTdgQFwIQEgXJ1jhN4KPLQv5SBtw7rE7uvAWDt0NoXYuiTB7Dwbk3eYk8Z6LAQrgpeEAV5JAXsQUIrBVgpLSRkrJPlt55LybwRUJTiAuT0Bw4QohxC8K2QItQfcRGkEcmiJItCGn51IG03giTz64KSLgoaVBkmpPSZITJYiFm5PyRoQpHhV7RDKRU7pY8amWQGImBpPdSDNPqTc/uHBOkjx6a3FpDT1jxPaQPUF1Sc6cDMFi25OKqnN1IGg4gaRnCSCAA">view on Godbolt</a>: <a href="#fr-2-1">↩</a></p>
</li>
</ol><div style="break-before: page; page-break-before: always;"></div><h1 id="miscellaneous-implementation-details"><a class="header" href="#miscellaneous-implementation-details">Miscellaneous Implementation Details</a></h1>
<p><code>bitvec</code> has a number of internal implementation details used to facilitate
development but are not part of the public API. While not user-facing, these
details are nevertheless important to document as explanations for how the
library is built.</p>
<h2 id="integer-refinement"><a class="header" href="#integer-refinement">Integer Refinement</a></h2>
<p><code>bitvec</code> offloads abstraction over the fundamental integers to <code>funty</code>,
described earlier in this guide.</p>
<p><code>funty</code> only unifies the standard-library APIs of the integers into trait-based
code; <code>bitvec</code> further extends this with useful constants in the <code>BitRegister</code>
trait. This trait delimits the integers that correspond to machine registers
actually available for use as storage, and provides minor conveniences for
working with them.</p>
<h2 id="specialization-hacks"><a class="header" href="#specialization-hacks">Specialization Hacks</a></h2>
<p><code>bitvec</code> is built to be agnostic to the ordering of bits within an element. This
is an important aspect of its design, and even if no other ordering than the
provided <code>Lsb0</code> and <code>Msb0</code> are used, <em>must</em> remain so that these two orderings
can be used on equal footing. However, the deferral of register operations to
type parameters outside of the data structures’ control results in some
unpleasant performance losses that would not occur in a hand-written equivalent.</p>
<p>Some operations, like copying between, or comparing, slices, can be accelerated
with partial-element access, but require knowledge of the <code>O</code> ordering type to
provide a semantic interpretation of register contents. Language-level
specialization could allow writing override <code>impl</code> blocks, like this:</p>
<pre><code class="language-rust">impl&lt;T, O&gt; BitSlice&lt;T, O&gt;
where
  T: BitStore,
  O: BitOrder,
{
  fn eq(&amp;self, other: &amp;Self) -&gt; bool {
    todo!("baseline")
  }
}

impl&lt;T&gt; BitSlice&lt;T, Lsb0&gt;
where T: BitStore {
  fn eq(&amp;self, other: &amp;Self) -&gt; bool {
    todo!("lsb0-accelerated version")
  }
}

impl&lt;T&gt; BitSlice&lt;T, Msb0&gt;
where T: BitStore {
  fn eq(&amp;self, other: &amp;Self) -&gt; bool {
    todo!("msb0-accelerated version")
  }
}</code></pre>
<p>While waiting on this feature, we can use the compiler’s stable <code>TypeId</code> API to
simulate access to specialization. By comparing the <code>TypeId</code> of the <code>O</code> type
argument to the <code>TypeId</code>s of <code>bitvec</code>’s provided orderings, functions can detect
when they are in a monomorphization with an <code>Lsb0</code> or <code>Msb0</code> ordering argument
and specialize accordingly. The above block can be replaced with:</p>
<pre><code class="language-rust">impl&lt;T, O&gt; BitSlice&lt;T, O&gt;
where
  T: BitStore,
  O: BitOrder,
{
  fn eq(&amp;self, other: &amp;Self) -&gt; bool {
    if let (Some(this), Some(that)) = (
      self.coerce::&lt;T, Lsb0&gt;(),
      other.coerce::&lt;T, Lsb0&gt;(),
    ) {
      todo!("lsb0-accelerated version")
    }
    else if let (Some(this), Some(that)) = (
      self.coerce::&lt;T, Msb0&gt;(),
      other.coerce::&lt;T, Msb0&gt;(),
    ) {
      todo!("msb0-accelerated version")
    }
    else {
      todo!("baseline")
    }
  }
}</code></pre>
<p>and, during monomorphization, only one branch of the <code>if</code> stack will be
preserved. The <code>.coerce()</code> method is defined in <code>slice::specialization</code> and
provides easy access to a fully-typed value only within the monomorphization
that matches it. It is not public API – your code <em>using</em> <code>bitvec</code> should prefer
being fully typed rather than generic.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="afterword"><a class="header" href="#afterword">Afterword</a></h1>
<p>Thanks for reading! We hope this guide was useful to you.</p>
<p><strong>Please</strong> feel both welcomed and encouraged to ask us any clarifying questions
(contact information for myrrlyn is in the <code>CONTRIBUTING</code> document), or to
<a href="https://github.com/ferrilab/ferrilab/issues/new">file an issue</a> if any of it is confusing or even send a PR if you have
improvements!</p>
<p>Ferrilab has been a work of intensely deep focus and research for over four
years. It is a complex and difficult topic, and we are absolutely certain that
we have information and context that we haven’t sufficiently serialized for
everyone else to see.</p>
<p>Thank you for using our crates. We are delighted that other people have found
our work both interesting and useful, and we’re glad that we’ve been able to
help people like you write better programs.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>


    </div>
    </body>
</html>
