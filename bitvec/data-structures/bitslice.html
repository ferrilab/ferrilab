<!DOCTYPE HTML>
<html lang="en-US" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>BitSlice - A User’s Guide to the Ferrilab Project</title>


        <!-- Custom HTML head -->

        <meta name="description" content="A more thorough exploration of Ferrilab’s crates.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../.././guide/assets/mdbook-admonish.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">A User’s Guide to the Ferrilab Project</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/ferrilab/ferrilab" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="slices"><a class="header" href="#slices">Slices <!-- omit in toc --></a></h1>
<ol>
<li><a href="#getting-a-bitslice">Getting a <code>BitSlice</code></a>
<ol>
<li><a href="#borrowing-constructors">Borrowing Constructors</a></li>
<li><a href="#macro-constructor">Macro Constructor</a></li>
</ol>
</li>
<li><a href="#what-bitslice-can-do">What <code>BitSlice</code> Can Do</a>
<ol>
<li><a href="#-that-bool-can">… That <code>[bool]</code> Can</a></li>
<li><a href="#-that-bool-cannot">… That <code>[bool]</code> Cannot</a></li>
<li><a href="#set-queries">Set Queries</a></li>
<li><a href="#boolean-arithmetic">Boolean Arithmetic</a></li>
<li><a href="#writing-to-memory">Writing To Memory</a></li>
<li><a href="#viewing-the-underlying-memory">Viewing the Underlying Memory</a></li>
</ol>
</li>
<li><a href="#footnotes">Footnotes</a></li>
</ol>
<p>The base type of the project is <code>BitSlice</code>. This is a region type, like
<code>[bool]</code>, and cannot be held directly. Instead, it is accessed by borrowed
references (<code>&amp;BitSlice</code>, <code>&amp;mut BitSlice</code>) or owning handles (<code>BitArray</code>,
<code>BitBox</code>, <code>BitVec</code>). The distinction between the handles and the region is the
same as it is in ordinary Rust types.</p>
<p>The <code>BitSlice</code> region is able to begin and end at any bit in memory, and is not
restricted to having one edge aligned to the edge of its initial element. This
restriction, present in all of its competitors, is removed through the use of a
special encoding in all pointers to the region, which stores the starting bit of
the base element in part of the slice pointer that describes the real memory.</p>
<p>There are eight bits to a byte on all systems Rust targets, and therefore the
index of a bit within a byte is itself three bits wide. These bits are taken
from the length counter of a slice pointer, which means that <code>BitSlice</code> is able
to address only ⅛<sup>th</sup> of the indices that <code>[bool]</code> can.</p>
<pre><code class="language-admonish info">This is 64 [Mebibytes] on a 32-bit system, and 256 [Pebibytes] on a 64-bit
system. If you can even allocate that much real memory in one handle, then you
have very different operating conditions than I can help you with.

[Mebibytes]: https://en.wikipedia.org/wiki/Mebibyte
[Pebibytes]: https://en.wikipedia.org/wiki/Pebibyte
</code></pre>
<h2 id="getting-a-bitslice"><a class="header" href="#getting-a-bitslice">Getting a <code>BitSlice</code></a></h2>
<p><code>BitSlice</code> is strictly a borrowed region. It can neither be created nor
destroyed; rather, views to it are acquired from a memory buffer that some other
binding owns.</p>
<p>The <a href="../type-parameters/bitstore.html"><code>BitStore</code> chapter</a> covers this in more detail, but only slices of the
unsigned integers <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>usize</code>, and (on 64-bit targets) <code>u64</code> can
be used as the source memory for a <code>BitSlice</code>. (You can also use their <code>Cell&lt;&gt;</code>
wrappers or atomic variants; this will be discussed later).</p>
<h3 id="borrowing-constructors"><a class="header" href="#borrowing-constructors">Borrowing Constructors</a></h3>
<p>The simplest way to create a <code>BitSlice</code> reference is to borrow it from ordinary
Rust data. The <a href="https://docs.rs/bitvec/latest/bitvec/view/trait.BitView.html"><code>BitView</code></a> trait, available in the <a href="https://docs.rs/bitvec/latest/bitvec/prelude">prelude</a>, implements methods
on the supported unsigned integers, all arrays of them, and their slices.</p>
<pre><code class="language-rust">use bitvec::prelude::*;

let byte = 0u8;
let bits = byte.view_bits::&lt;LocalBits&gt;();

let array = [0u16; 2];
let bits = array.view_bits::&lt;Lsb0&gt;();

let mut array = [0u32; 3];
let slice = &amp;mut array[..];
let bits = slice.view_bits_mut::&lt;Msb0&gt;();</code></pre>
<p>The <code>.view_bits()</code> and <code>.view_bits_mut()</code> methods take the other type parameter
<code>bitvec</code> requires. This is described in the <a href="../type-parameters/bitorder.html"><code>BitOrder</code> chapter</a>. Use <code>Lsb0</code>
until you have a specific need for a more precise parameter.</p>
<p>In addition, <code>BitSlice</code> offers constructor functions <code>::from_element()</code>,
<code>::from_slice()</code>, and their <code>_mut</code> variants, which borrow elements and slices,
respectively, and construct <code>&amp;/mut BitSlice</code> references from them. The trait
methods are generally easier, and certainly shorter to write, but they all do
the same work.</p>
<p>Lastly, empty slices can be produced with the <code>::empty()</code> or <code>::empty_mut()</code>
functions, since there is no <code>&amp;[]</code> or <code>&amp;mut []</code> literal available.</p>
<h3 id="macro-constructor"><a class="header" href="#macro-constructor">Macro Constructor</a></h3>
<p>In addition to these method constructors, you may also use the <a href="https://docs.rs/bitvec/latest/bitvec/macro.bits.html"><code>bits!</code></a>
constructor macro. This macro runs at compile-time to produce a buffer
containing the correct data values, then borrows it as a <code>BitSlice</code> reference.
It is a <code>macro_rules!</code> macro, not a procedural macro, and should not have a
significant impact on your compilation times.</p>
<p>By default, the produced buffer is a temporary that the compiler will then
extend to have the minimum lifetime of the produced reference handle. However,
you can use the <code>static</code> keyword to cause the macro to produce a hidden and
unnameable <code>static BitArray</code> backing buffer, which then provides the
<code>&amp;'static BitSlice</code> lifetime. Since this <code>static</code> buffer cannot be named, it is
safe to use even when <code>mut</code>able, as the provided reference is the only handle to
it.</p>
<p>The macro syntax extends that of <code>vec!</code>. The simplest invocations are sequences
or repetitions of expressions, which can optionally be made <code>mut</code>able:</p>
<pre><code class="language-rust">use bitvec::prelude::*;

let r = bits![0, 1, 0, 1];
let w = bits![mut 0, 1, 0, 1];

let r2 = bits![static 1; 4];
let w2 = unsafe { bits![static mut 1; 4] };</code></pre>
<pre><code class="language-admonish info">You are not required to use the literals `0` or `1`; you can use any expression
that is `const`-evaluable and can be placed into the expression `expr != 0`.
This means that you cannot use the names of runtime `let` bindings, but can use
the names of `const` bindings, or other literals. You probably do not want to do
this, but you *can*.
</code></pre>
<p>In addition, you can specify the bit-ordering integer storage type parameters
for even more precise control over the memory layout. If you do not specify
them, the macro uses the default parameters of <code>usize</code> storage and <code>Lsb0</code>
ordering.</p>
<pre><code class="language-rust">use bitvec::prelude::*;

let in_bytes = bits![u8, LocalBits; 0, 1, 0, 1];
let in_shorts = bits![u16, Lsb0; 0, 1, 0, 1];
let in_ints = bits![mut u32, Msb0; 0; 4];</code></pre>
<p>To summarize the macro rules:</p>
<ul>
<li>If the first macro argument is <code>mut</code>, then the macro produces <code>&amp;mut BitSlice</code>,
otherwise it produces <code>&amp;BitSlice</code>. You do not need to bind the name as <code>mut</code>
unless you want to reässign it to a different slice.</li>
<li>You may then optionally provide the storage and ordering type parameters,
followed by a semicolon. You must provide either both or neither.</li>
<li>The data input to the macro is one of the two <code>vec!</code> token lists:
<ul>
<li>One or more expressions that can be placed into <code>$expr != 0</code>, separated by
commas. A trailing comma is permitted.</li>
<li>A single expression that can be placed into <code>$expr != 0</code>, followed by a
semicolon and a repetition counter. The resulting <code>BitSlice</code> will be
<code>counter</code> bits long, all set to <code>expression</code>.</li>
</ul>
</li>
</ul>
<pre><code class="language-admonish warning">Emulation tests indicate that `bitvec` correctly instructs the compiler to
produce suitable buffers even when compiling for a target with a different
byte-endianness than the host. However, I have not actually performed such
cross-compilation and testing with real hardware. It should be correct; please
file an issue if it is not.
</code></pre>
<h2 id="what-bitslice-can-do"><a class="header" href="#what-bitslice-can-do">What <code>BitSlice</code> Can Do</a></h2>
<p>Now that you have acquired a <code>BitSlice</code> reference, either by borrowing memory
from elsewhere in your program or by creating a temporary, it is time to do some
actual work with it.</p>
<h3 id="-that-bool-can"><a class="header" href="#-that-bool-can">… That <code>[bool]</code> Can</a></h3>
<p>Everything<sup class="footnote-reference" id="fr-1-1"><a href="#footnote-1">1</a></sup>. I am not going to rewrite the standard library’s slice
documentation here.</p>
<h3 id="-that-bool-cannot"><a class="header" href="#-that-bool-cannot">… That <code>[bool]</code> Cannot</a></h3>
<p>In addition to the standard library <code>[bool]</code> API, <code>BitSlice</code> offers some
inherent methods tailored to its specialization.</p>
<h3 id="set-queries"><a class="header" href="#set-queries">Set Queries</a></h3>
<p>The five query methods <code>.any()</code>, <code>.all()</code>, <code>.not_any()</code>, <code>.not_all()</code>, and
<code>.some()</code> test how many bits in a region are set to <code>1</code>. These methods have the
following truth table:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Slice</th><th style="text-align: center"><code>any</code></th><th style="text-align: center"><code>all</code></th><th style="text-align: center"><code>not_any</code></th><th style="text-align: center"><code>not_all</code></th><th style="text-align: center"><code>some</code></th></tr></thead><tbody>
<tr><td style="text-align: center"><code>00</code></td><td style="text-align: center"><code>false</code></td><td style="text-align: center"><code>false</code></td><td style="text-align: center"><code>true</code></td><td style="text-align: center"><code>true</code></td><td style="text-align: center"><code>false</code></td></tr>
<tr><td style="text-align: center"><code>01</code></td><td style="text-align: center"><code>true</code></td><td style="text-align: center"><code>false</code></td><td style="text-align: center"><code>false</code></td><td style="text-align: center"><code>true</code></td><td style="text-align: center"><code>true</code></td></tr>
<tr><td style="text-align: center"><code>11</code></td><td style="text-align: center"><code>true</code></td><td style="text-align: center"><code>true</code></td><td style="text-align: center"><code>false</code></td><td style="text-align: center"><code>false</code></td><td style="text-align: center"><code>false</code></td></tr>
</tbody></table>
</div>
<p><code>any</code> is the Boolean OR operator; <code>all</code> is the Boolean AND operator, and <code>some</code>
is the Boolean XOR operator.</p>
<p>In addition, <code>.count_ones()</code> and <code>.count_zeros()</code> count how many bits of the
slice are set to one or zero, rather than merely indicating whether any exist.
These methods are slower than the Boolean queries, which are capable of
short-circuiting once satisfied.</p>
<p>You can also use <code>.iter_ones()</code> and <code>.iter_zeros()</code> to walk each <em>index</em> of bits
with the specified value. These are equivalent to running <code>.filter()</code> and
<code>.enumerate()</code> calls on iterators of <code>bool</code>, but are specialized to use
dedicated bit-counting instructions where processors provide them.</p>
<h3 id="boolean-arithmetic"><a class="header" href="#boolean-arithmetic">Boolean Arithmetic</a></h3>
<p><code>bitvec</code> data structures all implement the Boolean operators (<code>&amp;</code>, <code>|</code>, <code>^</code>, and
<code>!</code>) against each other.</p>
<pre><code class="language-admonish warning">In version 0, they allowed any `impl Iterator&lt;Item = bool&gt;`. This has been
changed for performance reasons, since people never used the arbitrary iterator
support but did require improved behavior when operating on two bit-slices.

These still have performance degradations, as the conditions required to allow
specialized acceleration can be difficult to guarantee at either run- or
compile- time. We are working on it, but cannot make any promises.
</code></pre>
<pre><code class="language-rust">use bitvec::prelude::*;

let mut or  =  bits![mut 0, 0, 1, 1];
        or |=  bits![    0, 1, 0, 1];
assert_eq!(or, bits![    0, 1, 1, 1]);

let mut and  =  bits![mut 0, 0, 1, 1];
        and &amp;=  bits![    0, 1, 0, 1];
assert_eq!(and, bits![    0, 0, 0, 1]);

let mut xor  =  bits![mut 0, 0, 1, 1];
        xor ^=  bits![    0, 1, 0, 1];
assert_eq!(xor, bits![    0, 1, 1, 0]);

let mut not = bits![mut 0, 1];
        not = !not;
assert_eq!(not, bits![  1, 0]);</code></pre>
<h3 id="writing-to-memory"><a class="header" href="#writing-to-memory">Writing To Memory</a></h3>
<p>You can set all bits in a region to a new value by using the <code>.fill()</code> method,
or you can set one bit in a region to a new value by using either the <code>.set</code> or
<code>.get_mut</code> methods. <code>.get_mut</code> produces a proxy type which acts roughly like an
<code>&amp;mut bool</code> reference slot.</p>
<pre><code class="language-rust">use bitvec::prelude::*;

let bits = bits![0; 4];
assert!(bits.not_any());

bits[0 .. 1].set_all(true);
assert!(bits[0]);

bits.set(1, true);
assert!(bits[1]);

*bits.get_mut(2).unwrap() = true;
assert!(bits[2]);

let mut bit = bits.get_mut(3).unwrap();
assert!(!bit);
*bit = true;
assert!(bits[3]);

assert!(bits.all());</code></pre>
<p>The proxy type produced by <code>.get_mut()</code> implements <code>DerefMut&lt;Target = bool&gt;</code>, so
you can assign into it and read out of it. However, it does not commit the value
assigned into it back to its source <code>BitSlice</code> until it <code>Drop</code>s.</p>
<p>You can force the destruction of a named proxy reference by using its
<code>.commit()</code> method, which takes <code>self</code> by value, destroying it and releasing the
borrow.</p>
<pre><code class="language-admonish warning">The proxy type is *not* a reference, which means you need to bind it with
`let mut` in order to be able to write through it as if it were a reference.
</code></pre>
<h3 id="viewing-the-underlying-memory"><a class="header" href="#viewing-the-underlying-memory">Viewing the Underlying Memory</a></h3>
<p>The memory underlying any bit-slice region is subject to some restrictions about
aliasing that are documented more thoroughly in the <a href="https://docs.rs/bitvec/latest/bitvec/domain"><code>domain</code></a> module and the
<a href="../memory-model.html"><em>Memory Model</em> chapter</a>. In short, borrowed <code>BitSlice</code> regions cannot view
their underlying memory directly without violating aliasing rules established by
either the Rust language or by <code>bitvec</code> itself. Instead, the <code>.domain()</code> and
<code>.domain_mut()</code> methods provide views that correctly handle aliasing and edge
conditions, and mediate access to the underlying memory.</p>
<p>The owning handles (<code>BitArray</code>, <code>BitVec</code>, and <code>BitBox</code>) do not have this
limitation, as they can guarantee unique access to a memory location without any
possibility of aliasing. As such, <em>these</em> types all have <code>.as_raw_slice()</code> and
<code>.as_raw_mut_slice()</code> methods that provide ordinary slice views to their storage
region.</p>
<h2 id="footnotes"><a class="header" href="#footnotes">Footnotes</a></h2>
<hr>
<ol class="footnote-definition"><li id="footnote-1">
<p>Except write-assignment through indexing. I am not going to keep
mentioning this exception. <a href="#fr-1-1">↩</a></p>
</li>
</ol>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../bitvec/data-structures.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../bitvec/data-structures/bitarray.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../bitvec/data-structures.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../bitvec/data-structures/bitarray.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
