<!DOCTYPE HTML>
<html lang="en-US" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Memory Model - A User’s Guide to the Ferrilab Project</title>


        <!-- Custom HTML head -->

        <meta name="description" content="A more thorough exploration of Ferrilab’s crates.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href=".././guide/assets/mdbook-admonish.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">A User’s Guide to the Ferrilab Project</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/ferrilab/ferrilab" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="bitvec-memory-model"><a class="header" href="#bitvec-memory-model"><code>bitvec</code> Memory Model</a></h1>
<p><code>bitvec</code> addresses individual bits, while computer hardware addresses register
elements. As a result, <code>bitvec</code> has a more complex memory model than the Rust
language does. The library implementation strives to satisfy users’
expectations, the Rust language’s rules, and performance in the produced
artifact to the best solution for all parties, with as few compromises as
possible. Unfortunately, this has the side effect of increasing the complexity
of the codebase, both for maintainers and for readers.</p>
<p>This chapter explains the abstract concepts of the <code>bitvec</code> memory model and the
means by which it is encoded in the Rust language without running afoul of Rust
or LLVM rules that threaten undefined behavior.</p>
<p>The <code>bitvec</code> memory model is typed entirely within the <code>store</code> module’s
<code>BitStore</code> trait definition and implementations. It utilizes the <code>access</code>
module’s <code>BitAccess</code> trait to mediate memory access events through types that
are known to be correct in the Rust and LLVM models, so that at any point in
program execution, memory access will be consistent and sound.</p>
<p>In addition, the <code>domain</code> module’s types provide views which manipulate the
<code>store</code> model to maximize performance. This chapter will discuss primarily
<code>store</code>, and use <code>domain</code> only to provide examples of how <code>store</code> is used in
practice to accomplish the library’s implementation.</p>
<h2 id="aliasing"><a class="header" href="#aliasing">Aliasing</a></h2>
<p>To Rust and LLVM, “aliasing” occurs whenever there are two paths to a memory
region, and at least one of them has write privileges. In Rust, this is
represented by the <code>&amp;mut</code> reference exclusion rule: it is always, always,
<strong>always</strong> Undefined Behavior in the <em>Rust</em> memory model to have two
<em>references</em> which can reach a memory element if at least one of them is marked
<code>&amp;mut</code>.</p>
<p>LLVM, which was created for, is written in, and culturally shaped by C++, takes
a similar view with its <code>noalias</code> annotation, but struggles to enforce it as
thoroughly as Rust does.</p>
<p><code>bitvec</code> takes a similar view of the abstract meaning of the <code>&amp;mut</code> reference
type, but where the Rust memory model focuses on whole units <code>T</code>, and has no
concept of subdivision from <code>T</code> into the bits that compose it, <code>bitvec</code> views
each individual bit as a standalone, independent, atom of memory. It excludes
the creation of two <code>&amp;mut BitSlice</code> reference handles that are capable of
viewing the same <em>bit</em>, but will happily produce two <code>&amp;mut BitSlice</code> handles
which are mutually-exclusive in bits, but reference the same location in memory.</p>
<pre><code class="language-admonish info">Think of it like disjoint `&amp;mut u64` references whose referent words are in the
same cacheline. The software model doesn’t care; making this work is the
hardware’s problem. Similarly, users of the `bitvec` library don’t need to care
about the fact that disjoint `&amp;mut BitSlice` references might refer to the same
element.
</code></pre>
<p>Here we come to the first problem with the conflicting memory models: <code>bitvec</code>
cannot ever create an <code>&amp;mut T</code> through which it may write to memory, because it
has no way of ensuring that no other <code>&amp;T</code> or <code>&amp;mut T</code> reference exists which is
capable of viewing the memory region into which it writes.</p>
<h3 id="rust-shared-mutation"><a class="header" href="#rust-shared-mutation">Rust Shared Mutation</a></h3>
<p>The problem isn’t just that the Rust standard library doesn’t offer any
non-<code>unsafe</code> APIs to produce such references. The problem is that this is about
the most illegal thing you can do in the eyes of the Rust compiler, and if it
ever detects this transgression, it has full liberty to either reject, or worse,
accept <em>and miscompile</em>, your program.</p>
<p>In Gankra’s <a href="https://doc.rust-lang.org/stable/nomicon/transmutes.html">immortal words</a> on the topic of attempting to sneak past the
compiler’s commandments,</p>
<blockquote>
<ul>
<li>Transmuting an <code>&amp;</code> to <code>&amp;mut</code> is <em>always</em> UB</li>
<li>No you can’t do it</li>
<li>No you’re not special</li>
</ul>
</blockquote>
<p>The solution is simple: Rust exposes a type, <a href="https://doc.rust-lang.org/stable/core/cell/struct.UnsafeCell.html"><code>UnsafeCell</code></a>, which is the
axiomatic type for mutation through shared views. In the Rust memory model, any
reference to a region of memory marked with <code>UnsafeCell</code> is permitted to write
to it, and if any other references can view that region, then it is up to them
to ensure consistent behavior.</p>
<p>This is, of course, not <em>quite</em> true in LLVM’s memory model, but we are not
there yet.</p>
<p>Since an <code>&amp;mut BitSlice&lt;T, _&gt;</code> handle cannot produce an <code>&amp;mut T</code> reference to
perform writes to memory, it must instead either use a <code>*mut T</code> bare pointer,
which has absolutely no checks or optimizations whatsoëver, or use an
<code>&amp;UnsafeCell&lt;T&gt;</code> shared reference, which has all the usual guarantees present on
all<sup class="footnote-reference" id="fr-1-1"><a href="#footnote-1">1</a></sup> reference types.</p>
<p>All <code>UnsafeCell</code> does is instruct the Rust compiler to politely look the other
way about your program’s memory accesses. It is somewhat like the C keyword
<code>volatile</code>, in that the compiler no longer believes that reads are stateless, or
freely reörderable, but entirely unlike that keyword in that the compiler
doesn’t have any obligation to <em>keep</em> your reads from or writes to such regions.</p>
<p>Rust provides an additional type called <a href="https://doc.rust-lang.org/stable/core/cell/struct.Cell.html"><code>Cell</code></a>. This is a wrapper over
<code>UnsafeCell</code><sup class="footnote-reference" id="fr-2-1"><a href="#footnote-2">2</a></sup> that defines a more useful API, including the only safe and
guaranteed way to write into memory through a shared reference: <a href="https://doc.rust-lang.org/stable/core/cell/struct.Cell.html#method.set"><code>Cell::set</code></a>.</p>
<p>And <em>voilà</em>: <code>&amp;mut BitSlice&lt;T, _&gt;</code> simply constructs <code>&amp;Cell&lt;T&gt;</code> when writing,
the Rust compiler does not see a violation of the <code>&amp;mut</code> exclusion principle,
and we are done.</p>
<h3 id="llvm-shared-mutation"><a class="header" href="#llvm-shared-mutation">LLVM Shared Mutation</a></h3>
<p>No we’re not. If it was that easy, there wouldn’t be a trait system or this
document dedicated specifically to dealing with this problem.</p>
<p><code>Cell</code> is not thread-safe, because <code>Cell</code> does not modify the instructions used
to access memory. It produces ordinary load and store instructions, carefree and
ignorant of the bane of everyone who wants consistency and the delight of
everyone who wants performance: concurrency.</p>
<p>Just as it is undefined behavior in Rust to manifest two <code>&amp;mut</code> references that
can view the same location, it is equally undefined behavior in LLVM to manifest
two pointers into memory that ever, at all, no matter <strong>what</strong>, perform any
memory access to the same location, at the same time, on multiple threads of
execution.</p>
<p>As with above:</p>
<blockquote>
<ul>
<li>Unsynchronized writes are <em>always</em> UB.</li>
<li>No you can’t do it.</li>
<li>No you’re not special.</li>
</ul>
</blockquote>
<p>LLVM has an even more insidious punishment for this transgression that Rust does
not directly express: unsynchronized reads from a data race produce <a href="https://llvm.org/docs/LangRef.html#poison-values"><code>poison</code></a>.
Poison is a nifty concept, because it’s not illegal to obtain one. When LLVM
gives you a <code>poison</code>, your program continues undergoing compilation as if
nothing had happened. You can pass it around. You can write to it, and if you
destroy it before reading, you’re fine.</p>
<p>As soon as you attempt to read the bit-wise value of <code>poison</code>, your program is
undefined<sup class="footnote-reference" id="fr-3-1"><a href="#footnote-3">3</a></sup>.</p>
<p>So if <code>bitvec</code> wants to be threadsafe, which it does, and it wants to insist on
its ability to safely alias the same memory location from multiple handles,
which is non-negotiable, there’s only one avenue left to take.</p>
<h3 id="atomic-powered-microscopes"><a class="header" href="#atomic-powered-microscopes">Atomic Powered Microscopes</a></h3>
<p>Rust doesn’t actually model atomics. It doesn’t have to do so: no harm can ever
come from multiple handles reading out of the same immutable location, harm can
only occur when writes are observable, and writes are not observable due to the
<code>&amp;mut</code> exclusion rule. Well, except for <code>UnsafeCell</code>, so everything that has an
<code>UnsafeCell</code> in it gets marked as <code>!Send</code>, <code>&amp;</code> references can’t cross threads,
and the whole problem is avoided.</p>
<p>This is, of course, not good enough. Concurrent, mutable, access to a location
is an important property in a computer. LLVM provides atomic types, which Rust
transparently exports as wrappers over <code>UnsafeCell</code> that have their <code>Sync</code>
implementation restored. Handles to a region marked as atomic will use some form
of hardware-provided exclusion in order to preserve the
one-writer-XOR-any-readers system behavior, and all is well.</p>
<p>Hardware-level exclusion has the unfortunate penalty of being, to put it
lightly, “slow”. So while it’s the safest choice to be correct, and was in fact
the default universal choice for all memory access in <code>bitvec</code> for some time,
its costs<sup class="footnote-reference" id="fr-4-1"><a href="#footnote-4">4</a></sup> called for a more prudent behavior.</p>
<p>It’s time for a new trick, something that the Rust compiler does at the region
level, and that <code>bitvec</code> now does at the element level:</p>
<h2 id="run-time-alias-analysis"><a class="header" href="#run-time-alias-analysis">Run Time Alias Analysis</a></h2>
<p><code>BitSlice</code> handles can only be constructed from ordinary Rust references to
memory, which Rust guarantees start out unaliased. The potential for aliasing
only occurs when a <code>&amp;mut BitSlice</code> is split into multiple subslices using any
of the functions that eventually call <code>.split_at_unchecked_mut()</code>. Since that is
the root function that introduces alias conditions, it returns subslices whose
memory type parameters are tainted with the <code>::Alias</code> marker. It has the
following type signature:</p>
<pre><code class="language-rust">impl&lt;T, O&gt; BitSlice&lt;T, O&gt;
where O: BitOrder, T: BitStore {
  pub fn split_at_unchecked_mut(&amp;mut self, at: usize) -&gt; (
    &amp;mut BitSlice&lt;T::Alias, O&gt;,
    &amp;mut BitSlice&lt;T::Alias, O&gt;,
  );
}</code></pre>
<p>The <code>BitStore</code> trait defines an <code>::Alias</code> associated type, which ensures that
all memory accesses through it have appropriate aliasing guards. For builds
which do not use the <code>atomic</code> feature (or where the target does not have an
atomic variant of the integer), this is <code>Cell</code>, and its protections are the loss
of thread-safety. For builds that do permit atomics, the marker enforces that
all reads and writes use atomic instructions.</p>
<p>The <code>::Alias</code> marker is applied, at compile time, by operations that split
<code>&amp;mut BitSlice</code> references into multiple coëxisting subslices. This is a good
first step to reducing unnecessary synchrony, but not good enough. Consider the
following:</p>
<pre><code class="language-rust">use bitvec::prelude::*;

let mut data = [0u8; 2];
let bits = data.view_bits_mut::&lt;Lsb0&gt;();
let (one, two) = data.split_at_mut(8);</code></pre>
<p>It so happens that this is equivalent to splitting <code>data</code> first, then viewing
each subslice as bits, but this transformation can only be done if the partition
point is known at compile-time to fall on an element boundary. There is no need
for the subslices <code>one</code> and <code>two</code> to use alias-safe operations, as accesses to
memory through them do not conflict with each other.</p>
<h3 id="bit-slice-domains"><a class="header" href="#bit-slice-domains">Bit Slice Domains</a></h3>
<p>The in-memory domain of any bit slice can be generalized to one of two formats:
either the slice touches zero edge-bits (<code>0</code> or <code>T::BITS - 1</code>), or it touches at
least one edge-bit in at least one element. Consider three bytes of memory (any
element will do, but the extra width on this page is unnecessary), with some
bitslice regions drawn within them:</p>
<pre><code class="language-text">|00000000│11111111│22222222| Element
|76543210│76543210│76543210│ Bit
├────────┼────────┼────────┤
│        ┆        ┆        │ 1
│        ┆xxxxx   ┆        │ 2
│        ┆ xxxxx  ┆        │ 3
│        ┆   xxxxx┆        │ 4
│  xxxxxx┆xxxx    ┆        │ 5
│    xxxx┆xxxxxxxx┆        │ 6
│        ┆xxxxxxxx┆xxxx    │ 7
│      xx┆xxxxxxxx┆xx      │ 8
│xxxxxxxx┆xxxxxxxx┆xxxxxxxx│ 9
</code></pre>
<p>There are nine example slices here, but they can be reduced into six specific
categories, and two general ones:</p>
<ol>
<li>empty: row 1</li>
<li>minor (interior of an element, no edge indices): row 3</li>
<li>partially-spanning head, fully-spanning body: rows 3 and 6</li>
<li>partially-spanning tail, fully-spanning body: rows 2 and 7</li>
<li>major (partial head, partial tail, full body): rows 5 and 8</li>
<li>spanning: row 9</li>
</ol>
<p>The minor slice (row 3) is irreducible; the rest can all be divided into three
subcomponents:</p>
<ul>
<li>zero or one partially-occupied head element, where the slice touches the last
index in it but not the first</li>
<li>zero or more fully-occupied middle elements, where the slice touches all
indices in each</li>
<li>zero or one partially-occupied tail element, where the slice touches the first
index in it but not the last</li>
</ul>
<p>We can break each row down into these components:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Row</th><th style="text-align: center">Head</th><th style="text-align: center">Body</th><th style="text-align: center">Tail</th></tr></thead><tbody>
<tr><td style="text-align: center">1</td><td style="text-align: center">None</td><td style="text-align: center">0</td><td style="text-align: center">None</td></tr>
<tr><td style="text-align: center">2</td><td style="text-align: center">None</td><td style="text-align: center">0</td><td style="text-align: center">Some</td></tr>
<tr><td style="text-align: center">4</td><td style="text-align: center">Some</td><td style="text-align: center">0</td><td style="text-align: center">None</td></tr>
<tr><td style="text-align: center">5</td><td style="text-align: center">Some</td><td style="text-align: center">0</td><td style="text-align: center">Some</td></tr>
<tr><td style="text-align: center">6</td><td style="text-align: center">Some</td><td style="text-align: center">1</td><td style="text-align: center">None</td></tr>
<tr><td style="text-align: center">7</td><td style="text-align: center">None</td><td style="text-align: center">1</td><td style="text-align: center">Some</td></tr>
<tr><td style="text-align: center">8</td><td style="text-align: center">Some</td><td style="text-align: center">1</td><td style="text-align: center">Some</td></tr>
<tr><td style="text-align: center">9</td><td style="text-align: center">None</td><td style="text-align: center">3</td><td style="text-align: center">None</td></tr>
</tbody></table>
</div>
<p>We can observe that where a slice fully-spans some elements, those elements
cannot be mutated by any other reference. In the <code>&amp;BitSlice</code> case, all <code>&amp;mut</code>s
are forbidden by the compiler’s ordinary rules; in the <code>&amp;mut BitSlice</code> case,
<code>bitvec</code>’s obedience to those same rules forbids any other handle from observing
the bits covered by the <code>&amp;mut BitSlice</code>. As such, it is statically impossible
for any alias to exist to the described memory in row 9, or for any alias to
observe element <code>1</code> of rows 6 through 8.</p>
<p><code>bitvec</code> happily permits element-aliasing <code>&amp;mut BitSlice</code> references to observe
the partially-filled elements in the outer columns, and middle column of rows 2
through 5, so writes to them must remain synchronized through either
single-threaded <code>Cell</code> or concurrency-safe atomics. These domain components can
be calculated from the three components of a slice pointer: the base address,
the starting bit index, and the bit count.</p>
<p>This is expressed in the <code>domain</code> module’s two enums.</p>
<h3 id="bitdomain"><a class="header" href="#bitdomain"><code>BitDomain</code></a></h3>
<p>This enum splits any <code>BitSlice</code> region into its subcomponents, immutably or
mutably, respectively. It has the (rough) definition</p>
<pre><code class="language-rust">pub enum BitDomain&lt;'a, M, T, O&gt;
where
  M: Mutability,
  T: BitStore,
  O: BitOrder,
{
  Enclave(Reference&lt;'a, M, BitSlice&lt;T, O&gt;&gt;),
  Region {
    head: Reference&lt;'a, M, BitSlice&lt;T, O&gt;&gt;,
    body: Reference&lt;'a, M, BitSlice&lt;T::Unalias, O&gt;&gt;,
    tail: Reference&lt;'a, M, BitSlice&lt;T, O&gt;&gt;,
  },
}</code></pre>
<p>and, rather than granting direct memory access, merely removes any aliasing
markers from as much memory as possible. The subslices that partially fill their
base element do not need to add an additional aliasing marker, as the marker is
only required when writes to the element may collide. If the slice is immutable,
aliasing never occurs, so synchrony is never required. If the slice is mutable,
then the only way to get a partial edge slice is to either forget about some
bits from the main slice, which is <em>not</em> an alias event, or to split the slice,
which <em>is</em>, and splitting already marks the alias.</p>
<h3 id="domain"><a class="header" href="#domain"><code>Domain</code></a></h3>
<p>The bit domains are still bit slices, and do not offer a way to access the
backing memory. For operations where raw memory access is required, this enum
produces the same domain definitions, but typed for the bare elements rather
than their bits.</p>
<p>It has the (rough) definition</p>
<pre><code class="language-rust">pub enum Domain&lt;'a, M, T&gt;
where
  M: Mutability,
  T: BitStore,
{
  Enclave(PartialElement&lt;T&gt;),
  Region {
    head: Option&lt;PartialElement&lt;T&gt;&gt;,
    body: Reference&lt;'a, M, [T::Unalias]&gt;,
    tail: Option&lt;PartialElement&lt;T&gt;&gt;,
  },
}</code></pre>
<p>(The <code>PartialElement</code> type is a guarded reference which prevents accessing bits
that do not belong to the originating <code>BitSlice</code>.)</p>
<p>As with the bit domains, these domains will inherit any aliasing markers from
their source bitslice. The <code>::Alias</code> associated type enables the mutable domain
to produce references that allow mutation without adding an unnecessary
aliasing marker. Rust strongly forbids the production of <code>&amp;mut</code> references to
aliased memory elements, which is why the only <code>&amp;mut</code> reference in these views
is to memory that is fully known to be unaliased.</p>
<p>The <code>Domain</code> structure will produce bare <a href="https://doc.rust-lang.org/stable/core/sync/atomic">atomic</a> or <a href="https://doc.rust-lang.org/stable/core/cell/struct.Cell.html"><code>Cell</code></a> types in the
alias condition. This is necessary in order to avoid production of <code>&amp;mut</code>
references which alias (as this is undefined in the Rust abstract machine,
regardless of behavior), and safe because any other references to the same
location will be similarly aliased and capable of handling external mutation.</p>
<h2 id="llvm-suboptimizations"><a class="header" href="#llvm-suboptimizations">LLVM Suboptimizations</a></h2>
<p>LLVM considers a “racing read”, that is, any read from memory that could occur
contemporaneously with an atomic write, to be undefined behavior. This is a
reasonable view to take, but a pessimistic one. <code>bitvec</code> has information that
cannot be expressed to LLVM about which <strong>bits</strong> of an element it will observe
or modify, and <code>bitvec</code> is capable of guaranteeing that two distinct access
points will not be able to interfere with each other electrically. LLVM does not
know this, so it considers any write to memory to touch <em>all</em> bits of the
touched element, and any read from memory to view <em>all</em> bits of the fetched
element.</p>
<p><code>bitvec</code> exclusively<sup class="footnote-reference" id="fr-5-1"><a href="#footnote-5">5</a></sup> writes to contended memory with the Rust functions
<a href="https://doc.rust-lang.org/stable/core/sync/atomic/struct.AtomicUsize.html#method.fetch_and"><code>AtomicT::fetch_and</code></a> and <a href="https://doc.rust-lang.org/stable/core/sync/atomic/struct.AtomicUsize.html#method.fetch_or"><code>AtomicT::fetch_or</code></a>, which are mapped to the LLVM
instructions <a href="https://releases.llvm.org/10.0.0/docs/Atomics.html#libcalls-atomic"><code>__atomic_fetch_and_N</code></a> and
<a href="https://releases.llvm.org/10.0.0/docs/Atomics.html#libcalls-atomic"><code>__atomic_fetch_or_N</code></a>. It uses bitmasks that <em><code>bitvec</code></em> can
<a href="https://github.com/myrrlyn/bitvec/blob/HEAD/src/order.rs">guarantee</a> are non-intersecting, but this proof cannot be extended to
even the Rust compiler, let alone LLVM. These bitmasks are applied to register
values before using either of the <code>fetch_op</code> instructions, and after any reads
that use <a href="https://doc.rust-lang.org/stable/core/sync/atomic/struct.AtomicUsize.html#method.load"><code>AtomicT::load</code></a>/<a href="https://releases.llvm.org/10.0.0/docs/Atomics.html#libcalls-atomic"><code>__atomic_load_N</code></a>.</p>
<p>If the <code>bitvec</code> mask proofs were extendible to LLVM, and LLVM were to expand its
tracking of which bits of a memory address became <code>poison</code>ed by a memory write,
and which bits of a fetched memory value became un-<code>poison</code>ed by a masking
operation, then the compiler would be more able to observe that <code>bitvec</code> memory
accesses do not <em>observably</em> interfere with each other. This observation would
then define the behavior in the compiler’s memory model of racing writes/reads,
and permit an increased (possibly even complete) removal of synchrony guards.</p>
<pre><code class="language-admonish info">I am not aware of any processor hardware which fails to guarantee that all bits
of memory are fully defined at the clock edges of all instructions that use the
location. To the full extent my knowledge, all memory banks in all relevant
processors have a stable bit-value at the start of a tick, when reads occur, and
at the end of a tick, when writes commit. At no point does changing the value of
one bit of a memory component affect the electrical value of other bits in the
component.

This is not necessarily true of other storage devices, such as SSDs, but
`bitvec` can only be used to access storage cells mapped in the RAM address
space, which tend to all have this stability property.
</code></pre>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>The formal definition of the <code>bitvec</code> memory model extends the Rust
mutable-exclusion rules by refining memory regions to have bit-precision instead
of element-precision. The Rust compiler is only weakly capable of tracking the
region status of individual bits, and only in compiler-internal structures. LLVM
has a more robust arbitrary-bit-tracking capability, but similarly limits its
interface to external code.</p>
<p>Barring any errors in the <code>bitvec</code> implementation, the <code>bitvec</code> memory model is
fully sound in its behavior with regard to single-observer unsynchrony.
Synchronization is only added in order to correctly interface with <code>rustc</code> and
LLVM without causing either of them to introduce undefined behavior due to a
lack of information.</p>
<h2 id="footnotes"><a class="header" href="#footnotes">Footnotes</a></h2>
<hr>
<ol class="footnote-definition"><li id="footnote-1">
<p>all references to <code>T</code> where <code>T</code> is either <code>!Sized</code>, or
<code>mem::size_of::&lt;T&gt;()</code> is non-zero, that is. A fun quirk of Rust’s first-class
concept of zero-width types is that the only illegal value for a <code>&amp;Zst</code>
reference is null. Since there is nothing to load or store through a <code>&amp;Zst</code>
reference, the compiler doesn’t <em>care</em> what the reference value is, as it will
never be used to perform memory access. <a href="#fr-1-1">↩</a></p>
</li>
<li id="footnote-2">
<p>literally: <a href="https://doc.rust-lang.org/1.43.0/src/core/cell.rs.html#232-235">https://doc.rust-lang.org/1.43.0/src/core/cell.rs.html#232-235</a> <a href="#fr-2-1">↩</a></p>
</li>
<li id="footnote-3">
<p>This is not <em>absolutely</em> true. Like we saw with <code>UnsafeCell</code>, the only
immutable rule of compiler developers is that whenever they make an immutable
rule, they also provide a way to sidestep it. If you <a href="https://llvm.org/docs/LangRef.html#i-freeze"><code>freeze</code></a> a <code>poison</code>,
you are now free to read its value and act on it. LLVM just doesn’t make any
guarantees about what bit-pattern you’ll see. <a href="#fr-3-1">↩</a></p>
</li>
<li id="footnote-4">
<p>I’d feel a great deal more comfortable if I had firm knowledge of what
those costs actually <strong>were</strong>. An atomic write always issues a <code>lock</code>
instruction modifier on x86, and I have heard vastly different things about
what that actually <em>means</em>, from “it’s free if no other cache holds that
address” up to “it poisons the whole cacheline”, and have not had much luck
producing a benchmark that firmly demonstrates that unneeded atomic access is
a strict performance cost. <a href="#fr-4-1">↩</a></p>
</li>
<li id="footnote-5">
<p>In multithreading environments. Disabling atomics also disables <code>bitvec</code>’s
support for multithreading, so the penalty for aliasing is reduced to an
inability to remove redundant reads. <a href="#fr-5-1">↩</a></p>
</li>
</ol>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../bitvec/memory-representation.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../bitvec/performance.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../bitvec/memory-representation.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../bitvec/performance.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
