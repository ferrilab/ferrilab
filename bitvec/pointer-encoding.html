<!DOCTYPE HTML>
<html lang="en-US" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Pointer Encoding - A User’s Guide to the Ferrilab Project</title>


        <!-- Custom HTML head -->

        <meta name="description" content="A more thorough exploration of Ferrilab’s crates.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href=".././guide/assets/mdbook-admonish.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">A User’s Guide to the Ferrilab Project</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/ferrilab/ferrilab" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="bit-slice-pointer-encoding"><a class="header" href="#bit-slice-pointer-encoding">Bit Slice Pointer Encoding</a></h1>
<p><code>bitvec</code>’s core value proposition rests on the fact that it is capable of
defining an unsized slice type, and controlling references to it. The Rust
language rests heavily on the two reference types <code>&amp;</code> and <code>&amp;mut</code>, and does not
ordinarily allow these to be faked or created by anything other than the
compiler.</p>
<h2 id="rust-reference-rules"><a class="header" href="#rust-reference-rules">Rust Reference Rules</a></h2>
<p>It so happens that not only does Rust strongly guarantee the <a href="https://github.com/rust-lang/rust/blob/8558ccd/src/libcore/ptr/mod.rs#L220-L231">in-memory layout</a>
of a reference to a slice, it also provides a stable API for
<a href="https://github.com/rust-lang/rust/blob/8558ccd/src/libcore/slice/mod.rs#L5642-L5739">constructing values</a> of <code>&amp;[T]</code> type without using <code>mem::transmute</code>. Subject to
certain value requirements imposed by types, slice references can be constructed
through these functions and the compiler will accept them as valid.</p>
<p>These requirements traditionally make it difficult to encode non-address
information into a bare reference, since the compiler has a very firm
expectation that a reference to a type is immediately dereferenceäble to a value
of that type, but if your type happens to be zero-sized, then it can never exist
in memory, no loads or stores to it can ever be produced, and the compiler no
longer concerns itself with the actual bit-pattern value of references to it.</p>
<p>Which is why the definition of <code>BitSlice</code> is</p>
<pre><code class="language-rust">//  src/slice.rs

#[repr(transparent)]
pub struct BitSlice&lt;T, O&gt;
where
  T: BitStore,
  O: BitOrder,
{
  _mem: [()],
  _typ: PhantomData&lt;T&gt;,
  _ord: PhantomData&lt;O&gt;,
}</code></pre>
<p><code>BitSlice</code> is <code>[()]</code> (a slice of the unit value) with some markers that only the
type-checker can see. <code>&amp;BitSlice</code> is thus <code>&amp;[()]</code>, and <code>&amp;[()]</code> can have any
values it wants (except, of course, null) – the unit value has no alignment
requirements, can be placed anywhere in memory without worrying about whether
there is a backing allocation, and can have as many instances of itself as
desired.</p>
<p>Zero-sized types are an <em>absurdly</em> powerful concept when working with memory
that the language expects to be able to manifest at any time.</p>
<h2 id="pointer-encoding"><a class="header" href="#pointer-encoding">Pointer Encoding</a></h2>
<p>Slice references contain two pieces of information: the address of the base
element, and the number of elements, starting at the base, contained in the
slice region. Theoretically, bit-slice references have the same pair of
information: the address of the first bit, and the number of bits in the region.</p>
<p>However, computers are byte-addressed, not bit-addressed, so we need to store
three more bits (to select a bit in the base byte) somewhere in the reference.
Since slice references are defined as <code>{ base: *T, elts: usize }</code>, and there are
no<sup class="footnote-reference" id="fr-1-1"><a href="#footnote-1">1</a></sup> spare bits in <code>*const _</code>, the bits to store the base bit are taken out of
the length counter.</p>
<p>Reference address values are also required to be integer multiples of the
alignment of the referent type <code>T</code>. This alignment is, on all supported targets,
the width in bytes of the referent type. As a result, there are as many low bits
in the address of any <code>T</code> that are <em>guaranteed</em> to be the <code>0</code> value, as there
are bits needed to select a byte within the element. The end result is that the
length counter must always use three bits to store the starting bit, and the
base address will be composed of an aligned <code>T</code> address and an index of the
starting byte within it.</p>
<p>As Rust does not have bitfield syntax, a definition of the pointer structure in
C++ looks like something like this<sup class="footnote-reference" id="fr-2-1"><a href="#footnote-2">2</a></sup>:</p>
<pre><code class="language-cpp">template &lt;typename T&gt;
struct BitSpan {
  static_assert(
    std::is_unsigned&lt;T&gt;()
    &amp;&amp; sizeof(T) &lt;= sizeof(std::size_t)
    &amp;&amp; sizeof(T) &lt;= alignof(T)
  );

  // on little-endian systems, bitfields are
  // allocated from LSbit and move towards MSbit
  uintptr_t ptr_head : __builtin_ctzll(alignof(T));
  uintptr_t ptr_addr : (sizeof(uintptr_t) * 8)
                     - __builtin_ctzll(alignof(T));

  size_t len_head : 3;
  size_t len_bits : (sizeof(size_t) * 8) - 3;
};
</code></pre>
<p>In Rust, the structure is declared as</p>
<pre><code class="language-rust">// src/pointer.rs

#[repr(C)]
pub struct BitSpan&lt;T, O&gt;
where
  T: BitStore,
  O: BitOrder,
{
  ptr: NonNull&lt;u8&gt;,
  len: usize,
  _ty: PhantomData&lt;T&gt;,
  _or: PhantomData&lt;O&gt;,
}</code></pre>
<p>and the logical components must be accessed through get/set functions, rather
than through compiler-generated field stubs.</p>
<p>By marking the pointer as <code>NonNull</code>, <code>BitSpan</code> declares that it will never be a
null pointer and becomes subject to the same peephole optimization that allows
<code>mem::size_of::&lt;Option&lt;&amp;T&gt;&gt;() == mem::size_of::&lt;&amp;T&gt;()</code>. By marking it as
unconditionally a pointer to <code>u8</code>, we declare that all low bits of the address
value are in use, and none can be used as slots for anything else (since our
encoding is using them to select a byte within the <code>T</code>).</p>
<h2 id="significant-values"><a class="header" href="#significant-values">Significant Values</a></h2>
<p><code>BitSpan&lt;T, O&gt;</code> does not have any sentinel values of its own, but inherits from
<code>NonNull&lt;T&gt;</code>. The completely zero value is not a valid member of the <code>BitSpan</code>
type, but rather indicates <code>Option::&lt;BitSpan&lt;_, _&gt;&gt;::None</code>, and it uses the
dangling <code>NonNull</code> pointer value to indicate an instantiated pointer object
without an associated allocation.</p>
<p>Not all zero-length regions are dead: a cleared <code>BitVec</code> region has zero length
but owns an allocation, so it cannot discard its address information.</p>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>Rust requires that slice references have a specific ABI, but makes no
requirements about the encoding of values of those references for certain types.
We can supply our own ABI-equivalent structure, define functions that use the
structural encoding to compute the information needed to actually interact with
memory, and convert our structures into Rust-accepted slices through the
provided compiler API in <code>core</code>.</p>
<p>If and when the <code>ptr_metadata</code> feature stabilizes, <code>bitvec</code> will experiment with
discarding this packed encoding in favor of a three-word pointer. If the
unpacked pointer results in better performance by eliminating the need for the
special encoding, <code>bitvec</code> will release a new <strong>minor</strong> version with the changed
structure.</p>
<pre><code class="language-admonish info">`bitvec`’s MSRV policy is that raising compiler requirements is a minor change,
not major, and the pointer ABI is **not public interface**! You are already
forbidden from moving bit-region pointers out of a program, so this change will
not affect your program’s behavior.
</code></pre>
<h2 id="footnotes"><a class="header" href="#footnotes">Footnotes</a></h2>
<pre><code class="language-cpp">// compiles on x86-64 clang 15.0.0
#include &lt;climits&gt;
#include &lt;cstddef&gt;
#include &lt;cstdint&gt;
#include &lt;type_traits&gt;

static_assert(CHAR_BIT == 8, "this target is not supported");

template &lt;typename T&gt;
struct BitSpan {
  static_assert(
    std::is_unsigned&lt;T&gt;()
    &amp;&amp; sizeof(T) &lt;= sizeof(std::size_t)
    &amp;&amp; sizeof(T) &lt;= alignof(T),
    "this type is not supported as BitSpan storage"
  );

  uintptr_t ptr_head : __builtin_ctzll(alignof(T));
  uintptr_t ptr_addr : (sizeof(uintptr_t) * 8)
                    - __builtin_ctzll(alignof(T));

  size_t len_head : 3;
  size_t len_bits : (sizeof(size_t) * 8) - 3;
};

template &lt;&gt;
struct BitSpan&lt;uint8_t&gt; {
  // ptr_head is zero bits wide when targeting bytes
  uintptr_t ptr_addr;
  size_t len_head : 3;
  size_t len_bits : (sizeof(size_t) * 8) - 3;
};

static uint64_t data[4];

BitSpan&lt;uint8_t&gt; one() {
  return {
    .ptr_addr = (uintptr_t)&amp;data[0],
    .len_head = 1,
    .len_bits = 6,
  };
}

BitSpan&lt;uint16_t&gt; two() {
  return {
    .ptr_head = 1,
    .ptr_addr = (uintptr_t)&amp;data[1],
    .len_head = 1,
    .len_bits = 5,
  };
}
BitSpan&lt;uint32_t&gt; four() {
  return {
    .ptr_head = 2,
    .ptr_addr = (uintptr_t)&amp;data[2],
    .len_head = 3,
    .len_bits = 10,
  };
}
BitSpan&lt;uint64_t&gt; eight() {
  return {
    .ptr_head = 4,
    .ptr_addr = (uintptr_t)&amp;data[3],
    .len_head = 5,
    .len_bits = 25,
  };
}
</code></pre>
<hr>
<ol class="footnote-definition"><li id="footnote-1">
<p>On AMD64, pointers are actually aggregates of <a href="https://en.wikipedia.org/wiki/X86-64#Virtual_address_space_details">MMU translation pages</a>, and
processors only decode the low 48 or 57 bits of them, leaving the high 16 or 7
bits available for other information not part of the memory addressing system.
However, these processors also trap when attempting to dereference a pointer
whose high <code>[48:64]</code> or <code>[57:64]</code> bits do not have the same bit value as bit
<code>[47]</code> or <code>[56]</code>, and that bit is typically used to differentiate unprivileged
user memory from privileged kernel memory. Furthermore, this dead region does
not exist on 32-bit architectures, x86 or otherwise, and since <code>bitvec</code>
explicitly supports 32-bit systems, the use of dead bits only present on a
subset of supported targets and subject to their own extra rules is not
worthwhile. <a href="#fr-1-1">↩</a></p>
</li>
<li id="footnote-2">
<p>Here is a full code listing which you can also <a href="https://clang.godbolt.org/#z:OYLghAFBqd5QCxAYwPYBMCmBRdBLAF1QCcAaPECAMzwBtMA7AQwFtMQByARg9KtQYEAysib0QXACx8BBAKoBnTAAUAHpwAMvAFYTStJg1DIApACYAQuYukl9ZATwDKjdAGFUtAK4sGe1wAyeAyYAHI%2BAEaYxCAAbADspAAOqAqETgwe3r56KWmOAkEh4SxRMQm2mPYFDEIETMQEWT5%2BXJXVGXUNBEVhkdF6CvWNzTltQ929JWUSAJS2qF7EyOwc5gDMwcjeWADUJutu23gshAoH2CYaAIIbWzuY%2B4fIQ%2BhYVBdXt2abDNteewOR1ewQInxudz%2BDyebgIAE8kpgAPoEYhMM7g243CaOZBIpgKJSNCBuAAS1wASkiLABJAAqTwAIgdGbsABykfZmMwEBB4BS7YbATAEXb83YMVCihReJIpRqYdDmMyzA5WCE3AiYFhJAxamHwxHMNi7OmYobELwOXYWQhCJKGfbxdXXXa7HF4PEEokECBfN1u14gED8pFeBhpYAhJWHM3rbAQVU3ANc2LmWLuvAAL0wqCoEDpsxhLMzObzECDIDSOZRSddAfT6dLufzheL61ZYjwUfLhdI/ob3N54sNj3FkulsvlWvQuwJNrtDoY7qIaOFyoHqvWLoHXlBSVRKN2B%2BISIQmCYs5AuyRSIie9ojgYSIcWdotAgXZ7rdmW5dbr3QQTyPYDL3QYhdmvCtsxbCBAIIYCCCLAAqdk6xTDDMMwgBaG87wfJ8XwIN8Py/SUfz/L4B2rZFRXoZ9z0vSDdnWNVqJgo96LvM5mOgst8xo2tdlQtki1w1jtyo%2BJmUkjVri1HU9UeIFzVRK1RVtYQlyBeC2RRC4nX/XYAHpjOPQ9GNncUc2IVBdgiHiAHc8D2Rzz2XIURWCYB7LhLVzmTXZ4MQ8zTzA4g2MCwS6MYM8LyvFjIvraLdi4hyCAFKCaPLaKULQ3ZxKSkxpKK7F6lxILQViSQj3QJh6hMABWCxJCamSdxuTT7UMHTQT0sF412ARMETQyB2IEUlmXYqjLdAA6UC3ggks4P3Q8kPTOqGuajQ2v7QL5q4yymV2NoB0O2L0oFEtYn2%2BtivaqTmTkrrtMOeCuFifTBoIRzUFGmbxsm4hpudc7dgWiz4pOs6DohxbwJO1agPW1UzFiLamCaiwuD28G5qO6GS1h%2BsLufK6Tsau63QeoqSs6xceve0F1jMb7sF2fglgBsHAomggprGuHIdPY6SzMamAxF/ElqR4LUc2%2Bqseasw8eFwmmJLdZJbJ7iMphjRJdp2Tbnp65XqZtx4Oq9ndkwbsEF9ItAb54HQdm%2BGoc1jtdmkfGEeWn3kYQhX0cx7HWMaxkdYhjXZxLKn8bSnjxcTwLjZ3M2OHmWhOEa3g/A4LRSFQTg3Gsax3UWZZlJ%2BHhSAITRs/mABrEBGsN3OOEkAum5LzheAUEBDcbovs9IOBYBgRAUFQHU6GichKDQef6BibZDGALgO8NrAADdPUwAA1PBMEcgB5I1OHrmhH2iIeIAiPuHOYYg4Wv3gX4aOFz4ibRMAcB/UgK82CCHPgwWg78x6kCwCwTe4hoH4Amg4PAe9MBD2gZgVQACvBaiAaCKofdaB4AiGiN%2BHgsB91RCcD%2B8wqAGGAAoE%2BZ9L6MCAfwQQIgxDsCkDIQQigVDqGgboNoBgjAoArpYfQJCh6QHmKgA8GQMGDyqAAmoLgGDuE8C0fwmipj9BiG0PI6QBCjFaMkVIJiGD6NKAMcYqiUECC6CMbRYx2hqM6MMHowQ%2Bi2MMbYLxZjBheJsTMLg8wFDVxWHMfQede7QNLhwXYqg2SxGwtVXYG8jCnUanNDQeTdgQFwIQEgXJ1jhN4KPLQv5SBtw7rE7uvAWDt0NoXYuiTB7Dwbk3eYk8Z6LAQrgpeEAV5JAXsQUIrBVgpLSRkrJPlt55LybwRUJTiAuT0Bw4QohxC8K2QItQfcRGkEcmiJItCGn51IG03giTz64KSLgoaVBkmpPSZITJYiFm5PyRoQpHhV7RDKRU7pY8amWQGImBpPdSDNPqTc/uHBOkjx6a3FpDT1jxPaQPUF1Sc6cDMFi25OKqnN1IGg4gaRnCSCAA">view on Godbolt</a>: <a href="#fr-2-1">↩</a></p>
</li>
</ol>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../bitvec/performance.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../bitvec/miscellaneous.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../bitvec/performance.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../bitvec/miscellaneous.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
